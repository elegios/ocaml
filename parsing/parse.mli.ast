[
  signature_item (parsing/parse.mli[16,1079+0]..[21,1198+2])
    Psig_attribute "ocaml.text"
    [
      structure_item (parsing/parse.mli[16,1079+0]..[21,1198+2])
        Pstr_eval
        expression (parsing/parse.mli[16,1079+0]..[21,1198+2])
          Pexp_constant PConst_string(" Entry points in the parser\n\n  {b Warning:} this module is unstable and part of\n  {{!Compiler_libs}compiler-libs}.\n\n",(parsing/parse.mli[16,1079+0]..[21,1198+2]),None)
    ]
  signature_item (parsing/parse.mli[23,1202+0]..[23,1202+57])
    Psig_value
    value_description "implementation" (parsing/parse.mli[23,1202+4]..[23,1202+18]) (parsing/parse.mli[23,1202+0]..[23,1202+57])
      core_type (parsing/parse.mli[23,1202+21]..[23,1202+57])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[23,1202+21]..[23,1202+34])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[23,1202+21]..[23,1202+34])
          []
        core_type (parsing/parse.mli[23,1202+38]..[23,1202+57])
          Ptyp_constr "Parsetree.structure" (parsing/parse.mli[23,1202+38]..[23,1202+57])
          []
      []
  signature_item (parsing/parse.mli[24,1260+0]..[24,1260+52])
    Psig_value
    value_description "interface" (parsing/parse.mli[24,1260+4]..[24,1260+13]) (parsing/parse.mli[24,1260+0]..[24,1260+52])
      core_type (parsing/parse.mli[24,1260+16]..[24,1260+52])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[24,1260+16]..[24,1260+29])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[24,1260+16]..[24,1260+29])
          []
        core_type (parsing/parse.mli[24,1260+33]..[24,1260+52])
          Ptyp_constr "Parsetree.signature" (parsing/parse.mli[24,1260+33]..[24,1260+52])
          []
      []
  signature_item (parsing/parse.mli[25,1313+0]..[25,1313+64])
    Psig_value
    value_description "toplevel_phrase" (parsing/parse.mli[25,1313+4]..[25,1313+19]) (parsing/parse.mli[25,1313+0]..[25,1313+64])
      core_type (parsing/parse.mli[25,1313+22]..[25,1313+64])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[25,1313+22]..[25,1313+35])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[25,1313+22]..[25,1313+35])
          []
        core_type (parsing/parse.mli[25,1313+39]..[25,1313+64])
          Ptyp_constr "Parsetree.toplevel_phrase" (parsing/parse.mli[25,1313+39]..[25,1313+64])
          []
      []
  signature_item (parsing/parse.mli[26,1378+0]..[26,1378+62])
    Psig_value
    value_description "use_file" (parsing/parse.mli[26,1378+4]..[26,1378+12]) (parsing/parse.mli[26,1378+0]..[26,1378+62])
      core_type (parsing/parse.mli[26,1378+15]..[26,1378+62])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[26,1378+15]..[26,1378+28])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[26,1378+15]..[26,1378+28])
          []
        core_type (parsing/parse.mli[26,1378+32]..[26,1378+62])
          Ptyp_constr "list" (parsing/parse.mli[26,1378+58]..[26,1378+62])
          [
            core_type (parsing/parse.mli[26,1378+32]..[26,1378+57])
              Ptyp_constr "Parsetree.toplevel_phrase" (parsing/parse.mli[26,1378+32]..[26,1378+57])
              []
          ]
      []
  signature_item (parsing/parse.mli[27,1441+0]..[27,1441+52])
    Psig_value
    value_description "core_type" (parsing/parse.mli[27,1441+4]..[27,1441+13]) (parsing/parse.mli[27,1441+0]..[27,1441+52])
      core_type (parsing/parse.mli[27,1441+16]..[27,1441+52])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[27,1441+16]..[27,1441+29])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[27,1441+16]..[27,1441+29])
          []
        core_type (parsing/parse.mli[27,1441+33]..[27,1441+52])
          Ptyp_constr "Parsetree.core_type" (parsing/parse.mli[27,1441+33]..[27,1441+52])
          []
      []
  signature_item (parsing/parse.mli[28,1494+0]..[28,1494+54])
    Psig_value
    value_description "expression" (parsing/parse.mli[28,1494+4]..[28,1494+14]) (parsing/parse.mli[28,1494+0]..[28,1494+54])
      core_type (parsing/parse.mli[28,1494+17]..[28,1494+54])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[28,1494+17]..[28,1494+30])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[28,1494+17]..[28,1494+30])
          []
        core_type (parsing/parse.mli[28,1494+34]..[28,1494+54])
          Ptyp_constr "Parsetree.expression" (parsing/parse.mli[28,1494+34]..[28,1494+54])
          []
      []
  signature_item (parsing/parse.mli[29,1549+0]..[29,1549+48])
    Psig_value
    value_description "pattern" (parsing/parse.mli[29,1549+4]..[29,1549+11]) (parsing/parse.mli[29,1549+0]..[29,1549+48])
      core_type (parsing/parse.mli[29,1549+14]..[29,1549+48])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[29,1549+14]..[29,1549+27])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[29,1549+14]..[29,1549+27])
          []
        core_type (parsing/parse.mli[29,1549+31]..[29,1549+48])
          Ptyp_constr "Parsetree.pattern" (parsing/parse.mli[29,1549+31]..[29,1549+48])
          []
      []
  signature_item (parsing/parse.mli[31,1599+0]..[31,1599+65])
    Psig_attribute "ocaml.text"
    [
      structure_item (parsing/parse.mli[31,1599+0]..[31,1599+65])
        Pstr_eval
        expression (parsing/parse.mli[31,1599+0]..[31,1599+65])
          Pexp_constant PConst_string(" The functions below can be used to parse Longident safely. ",(parsing/parse.mli[31,1599+0]..[31,1599+65]),None)
    ]
  signature_item (parsing/parse.mli[33,1666+0]..[33,1666+43])
    Psig_value
    value_description "longident" (parsing/parse.mli[33,1666+4]..[33,1666+13]) (parsing/parse.mli[33,1666+0]..[33,1666+43])
      attribute "ocaml.doc"
        [
          structure_item (parsing/parse.mli[34,1710+0]..[48,2446+2])
            Pstr_eval
            expression (parsing/parse.mli[34,1710+0]..[48,2446+2])
              Pexp_constant PConst_string("\n   The function [longident] is guaranteed to parse all subclasses\n   of {!Longident.t} used in OCaml: values, constructors, simple or extended\n   module paths, and types or module types.\n\n   However, this function accepts inputs which are not accepted by the\n   compiler, because they combine functor applications and infix operators.\n   In valid OCaml syntax, only value-level identifiers may end with infix\n   operators [Foo.( + )].\n   Moreover, in value-level identifiers the module path [Foo] must be simple\n   ([M.N] rather than [F(X)]): functor applications may only appear in\n   type-level identifiers.\n   As a consequence, a path such as [F(X).( + )] is not a valid OCaml\n   identifier; but it is accepted by this function.\n",(parsing/parse.mli[34,1710+0]..[48,2446+2]),None)
        ]
      core_type (parsing/parse.mli[33,1666+15]..[33,1666+43])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[33,1666+15]..[33,1666+28])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[33,1666+15]..[33,1666+28])
          []
        core_type (parsing/parse.mli[33,1666+32]..[33,1666+43])
          Ptyp_constr "Longident.t" (parsing/parse.mli[33,1666+32]..[33,1666+43])
          []
      []
  signature_item (parsing/parse.mli[50,2450+0]..[50,2450+73])
    Psig_attribute "ocaml.text"
    [
      structure_item (parsing/parse.mli[50,2450+0]..[50,2450+73])
        Pstr_eval
        expression (parsing/parse.mli[50,2450+0]..[50,2450+73])
          Pexp_constant PConst_string(" The next functions are specialized to a subclass of {!Longident.t} ",(parsing/parse.mli[50,2450+0]..[50,2450+73]),None)
    ]
  signature_item (parsing/parse.mli[52,2525+0]..[52,2525+43])
    Psig_value
    value_description "val_ident" (parsing/parse.mli[52,2525+4]..[52,2525+13]) (parsing/parse.mli[52,2525+0]..[52,2525+43])
      attribute "ocaml.doc"
        [
          structure_item (parsing/parse.mli[53,2569+0]..[61,2930+2])
            Pstr_eval
            expression (parsing/parse.mli[53,2569+0]..[61,2930+2])
              Pexp_constant PConst_string("\n   This function parses a syntactically valid path for a value. For instance,\n   [x], [M.x], and [(+.)] are valid. Contrarily, [M.A], [F(X).x], and [true]\n   are rejected.\n\n   Longident for OCaml's value cannot contain functor application.\n   The last component of the {!Longident.t} is not capitalized,\n   but can be an operator [A.Path.To.(.%.%.(;..)<-)]\n",(parsing/parse.mli[53,2569+0]..[61,2930+2]),None)
        ]
      core_type (parsing/parse.mli[52,2525+15]..[52,2525+43])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[52,2525+15]..[52,2525+28])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[52,2525+15]..[52,2525+28])
          []
        core_type (parsing/parse.mli[52,2525+32]..[52,2525+43])
          Ptyp_constr "Longident.t" (parsing/parse.mli[52,2525+32]..[52,2525+43])
          []
      []
  signature_item (parsing/parse.mli[63,2934+0]..[63,2934+46])
    Psig_value
    value_description "constr_ident" (parsing/parse.mli[63,2934+4]..[63,2934+16]) (parsing/parse.mli[63,2934+0]..[63,2934+46])
      attribute "ocaml.doc"
        [
          structure_item (parsing/parse.mli[64,2981+0]..[75,3486+2])
            Pstr_eval
            expression (parsing/parse.mli[64,2981+0]..[75,3486+2])
              Pexp_constant PConst_string("\n   This function parses a syntactically valid path for a variant constructor.\n   For instance, [A], [M.A] and [M.(::)] are valid, but both [M.a]\n   and [F(X).A] are rejected.\n\n   Longident for OCaml's variant constructors cannot contain functor\n   application.\n   The last component of the {!Longident.t} is capitalized,\n   or it may be one the special constructors: [true],[false],[()],[[]],[(::)].\n   Among those special constructors, only [(::)] can be prefixed by a module\n   path ([A.B.C.(::)]).\n",(parsing/parse.mli[64,2981+0]..[75,3486+2]),None)
        ]
      core_type (parsing/parse.mli[63,2934+18]..[63,2934+46])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[63,2934+18]..[63,2934+31])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[63,2934+18]..[63,2934+31])
          []
        core_type (parsing/parse.mli[63,2934+35]..[63,2934+46])
          Ptyp_constr "Longident.t" (parsing/parse.mli[63,2934+35]..[63,2934+46])
          []
      []
  signature_item (parsing/parse.mli[78,3491+0]..[78,3491+52])
    Psig_value
    value_description "simple_module_path" (parsing/parse.mli[78,3491+4]..[78,3491+22]) (parsing/parse.mli[78,3491+0]..[78,3491+52])
      attribute "ocaml.doc"
        [
          structure_item (parsing/parse.mli[79,3544+0]..[86,3830+2])
            Pstr_eval
            expression (parsing/parse.mli[79,3544+0]..[86,3830+2])
              Pexp_constant PConst_string("\n   This function parses a syntactically valid path for a module.\n   For instance, [A], and [M.A] are valid, but both [M.a]\n   and [F(X).A] are rejected.\n\n   Longident for OCaml's module cannot contain functor application.\n   The last component of the {!Longident.t} is capitalized.\n",(parsing/parse.mli[79,3544+0]..[86,3830+2]),None)
        ]
      core_type (parsing/parse.mli[78,3491+24]..[78,3491+52])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[78,3491+24]..[78,3491+37])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[78,3491+24]..[78,3491+37])
          []
        core_type (parsing/parse.mli[78,3491+41]..[78,3491+52])
          Ptyp_constr "Longident.t" (parsing/parse.mli[78,3491+41]..[78,3491+52])
          []
      []
  signature_item (parsing/parse.mli[89,3835+0]..[89,3835+54])
    Psig_value
    value_description "extended_module_path" (parsing/parse.mli[89,3835+4]..[89,3835+24]) (parsing/parse.mli[89,3835+0]..[89,3835+54])
      attribute "ocaml.doc"
        [
          structure_item (parsing/parse.mli[90,3890+0]..[97,4126+2])
            Pstr_eval
            expression (parsing/parse.mli[90,3890+0]..[97,4126+2])
              Pexp_constant PConst_string("\n   This function parse syntactically valid path for an extended module.\n   For instance, [A.B] and [F(A).B] are valid. Contrarily,\n   [(.%())] or [[]] are both rejected.\n\n   The last component of the {!Longident.t} is capitalized.\n\n",(parsing/parse.mli[90,3890+0]..[97,4126+2]),None)
        ]
      core_type (parsing/parse.mli[89,3835+26]..[89,3835+54])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[89,3835+26]..[89,3835+39])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[89,3835+26]..[89,3835+39])
          []
        core_type (parsing/parse.mli[89,3835+43]..[89,3835+54])
          Ptyp_constr "Longident.t" (parsing/parse.mli[89,3835+43]..[89,3835+54])
          []
      []
  signature_item (parsing/parse.mli[99,4130+0]..[99,4130+44])
    Psig_value
    value_description "type_ident" (parsing/parse.mli[99,4130+4]..[99,4130+14]) (parsing/parse.mli[99,4130+0]..[99,4130+44])
      attribute "ocaml.doc"
        [
          structure_item (parsing/parse.mli[100,4175+0]..[108,4461+2])
            Pstr_eval
            expression (parsing/parse.mli[100,4175+0]..[108,4461+2])
              Pexp_constant PConst_string("\n   This function parse syntactically valid path for a type or a module type.\n   For instance, [A], [t], [M.t] and [F(X).t] are valid. Contrarily,\n   [(.%())] or [[]] are both rejected.\n\n   In path for type and module types, only operators and special constructors\n   are rejected.\n\n",(parsing/parse.mli[100,4175+0]..[108,4461+2]),None)
        ]
      core_type (parsing/parse.mli[99,4130+16]..[99,4130+44])
        Ptyp_arrow
        Nolabel
        core_type (parsing/parse.mli[99,4130+16]..[99,4130+29])
          Ptyp_constr "Lexing.lexbuf" (parsing/parse.mli[99,4130+16]..[99,4130+29])
          []
        core_type (parsing/parse.mli[99,4130+33]..[99,4130+44])
          Ptyp_constr "Longident.t" (parsing/parse.mli[99,4130+33]..[99,4130+44])
          []
      []
]

