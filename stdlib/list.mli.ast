[
  signature_item (stdlib/list.mli[24,1286+0]..[38,1935+3])
    Psig_attribute "ocaml.text"
    [
      structure_item (stdlib/list.mli[24,1286+0]..[38,1935+3])
        Pstr_eval
        expression (stdlib/list.mli[24,1286+0]..[38,1935+3])
          Pexp_constant PConst_string(" List operations.\n\n   Some functions are flagged as not tail-recursive.  A tail-recursive\n   function uses constant stack space, while a non-tail-recursive function\n   uses stack space proportional to the length of its list argument, which\n   can be a problem with very long lists.  When the function takes several\n   list arguments, an approximate formula giving stack usage (in some\n   unspecified constant unit) is shown in parentheses.\n\n   The above considerations can usually be ignored if your lists are not\n   longer than about 10000 elements.\n\n   The labeled version of this module can be used as described in the\n   {!StdLabels} module.\n ",(stdlib/list.mli[24,1286+0]..[38,1935+3]),None)
    ]
  signature_item (stdlib/list.mli[40,1940+0]..[40,1940+47])
    Psig_type Rec
    [
      type_declaration "t" (stdlib/list.mli[40,1940+8]..[40,1940+9]) (stdlib/list.mli[40,1940+0]..[40,1940+47])
        attribute "ocaml.doc"
          [
            structure_item (stdlib/list.mli[41,1993+0]..[41,1993+38])
              Pstr_eval
              expression (stdlib/list.mli[41,1993+0]..[41,1993+38])
                Pexp_constant PConst_string(" An alias for the type of lists. ",(stdlib/list.mli[41,1993+0]..[41,1993+38]),None)
          ]
        ptype_params =
          [
            core_type (stdlib/list.mli[40,1940+5]..[40,1940+7])
              Ptyp_var a
          ]
        ptype_cstrs =
          []
        ptype_kind =
          Ptype_variant
            [
              (stdlib/list.mli[40,1940+22]..[40,1940+24])
                "[]" (stdlib/list.mli[40,1940+22]..[40,1940+24])
                []
                None
              (stdlib/list.mli[40,1940+25]..[40,1940+47])
                "::" (stdlib/list.mli[40,1940+27]..[40,1940+31])
                [
                  core_type (stdlib/list.mli[40,1940+35]..[40,1940+37])
                    Ptyp_var a
                  core_type (stdlib/list.mli[40,1940+40]..[40,1940+47])
                    Ptyp_constr "list" (stdlib/list.mli[40,1940+43]..[40,1940+47])
                    [
                      core_type (stdlib/list.mli[40,1940+40]..[40,1940+42])
                        Ptyp_var a
                    ]
                ]
                None
            ]
        ptype_private = Public
        ptype_manifest =
          Some
            core_type (stdlib/list.mli[40,1940+12]..[40,1940+19])
              Ptyp_constr "list" (stdlib/list.mli[40,1940+15]..[40,1940+19])
              [
                core_type (stdlib/list.mli[40,1940+12]..[40,1940+14])
                  Ptyp_var a
              ]
    ]
  signature_item (stdlib/list.mli[43,2033+0]..[43,2033+27])
    Psig_value
    value_description "length" (stdlib/list.mli[43,2033+4]..[43,2033+10]) (stdlib/list.mli[43,2033+0]..[43,2033+27])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[44,2061+0]..[44,2061+64])
            Pstr_eval
            expression (stdlib/list.mli[44,2061+0]..[44,2061+64])
              Pexp_constant PConst_string(" Return the length (number of elements) of the given list. ",(stdlib/list.mli[44,2061+0]..[44,2061+64]),None)
        ]
      core_type (stdlib/list.mli[43,2033+13]..[43,2033+27])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[43,2033+13]..[43,2033+20])
          Ptyp_constr "list" (stdlib/list.mli[43,2033+16]..[43,2033+20])
          [
            core_type (stdlib/list.mli[43,2033+13]..[43,2033+15])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[43,2033+24]..[43,2033+27])
          Ptyp_constr "int" (stdlib/list.mli[43,2033+24]..[43,2033+27])
          []
      []
  signature_item (stdlib/list.mli[46,2127+0]..[46,2127+47])
    Psig_value
    value_description "compare_lengths" (stdlib/list.mli[46,2127+4]..[46,2127+19]) (stdlib/list.mli[46,2127+0]..[46,2127+47])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[47,2175+0]..[51,2391+3])
            Pstr_eval
            expression (stdlib/list.mli[47,2175+0]..[51,2391+3])
              Pexp_constant PConst_string(" Compare the lengths of two lists. [compare_lengths l1 l2] is\n   equivalent to [compare (length l1) (length l2)], except that\n   the computation stops after reaching the end of the shortest list.\n   @since 4.05.0\n ",(stdlib/list.mli[47,2175+0]..[51,2391+3]),None)
        ]
      core_type (stdlib/list.mli[46,2127+22]..[46,2127+47])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[46,2127+22]..[46,2127+29])
          Ptyp_constr "list" (stdlib/list.mli[46,2127+25]..[46,2127+29])
          [
            core_type (stdlib/list.mli[46,2127+22]..[46,2127+24])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[46,2127+33]..[46,2127+47])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[46,2127+33]..[46,2127+40])
            Ptyp_constr "list" (stdlib/list.mli[46,2127+36]..[46,2127+40])
            [
              core_type (stdlib/list.mli[46,2127+33]..[46,2127+35])
                Ptyp_var b
            ]
          core_type (stdlib/list.mli[46,2127+44]..[46,2127+47])
            Ptyp_constr "int" (stdlib/list.mli[46,2127+44]..[46,2127+47])
            []
      []
  signature_item (stdlib/list.mli[53,2396+0]..[53,2396+47])
    Psig_value
    value_description "compare_length_with" (stdlib/list.mli[53,2396+4]..[53,2396+23]) (stdlib/list.mli[53,2396+0]..[53,2396+47])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[54,2444+0]..[58,2664+3])
            Pstr_eval
            expression (stdlib/list.mli[54,2444+0]..[58,2664+3])
              Pexp_constant PConst_string(" Compare the length of a list to an integer. [compare_length_with l len] is\n   equivalent to [compare (length l) len], except that the computation stops\n   after at most [len] iterations on the list.\n   @since 4.05.0\n ",(stdlib/list.mli[54,2444+0]..[58,2664+3]),None)
        ]
      core_type (stdlib/list.mli[53,2396+26]..[53,2396+47])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[53,2396+26]..[53,2396+33])
          Ptyp_constr "list" (stdlib/list.mli[53,2396+29]..[53,2396+33])
          [
            core_type (stdlib/list.mli[53,2396+26]..[53,2396+28])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[53,2396+37]..[53,2396+47])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[53,2396+37]..[53,2396+40])
            Ptyp_constr "int" (stdlib/list.mli[53,2396+37]..[53,2396+40])
            []
          core_type (stdlib/list.mli[53,2396+44]..[53,2396+47])
            Ptyp_constr "int" (stdlib/list.mli[53,2396+44]..[53,2396+47])
            []
      []
  signature_item (stdlib/list.mli[60,2669+0]..[60,2669+35])
    Psig_value
    value_description "cons" (stdlib/list.mli[60,2669+4]..[60,2669+8]) (stdlib/list.mli[60,2669+0]..[60,2669+35])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[61,2705+0]..[63,2775+3])
            Pstr_eval
            expression (stdlib/list.mli[61,2705+0]..[63,2775+3])
              Pexp_constant PConst_string(" [cons x xs] is [x :: xs]\n    @since 4.03.0 (4.05.0 in ListLabels)\n ",(stdlib/list.mli[61,2705+0]..[63,2775+3]),None)
        ]
      core_type (stdlib/list.mli[60,2669+11]..[60,2669+35])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[60,2669+11]..[60,2669+13])
          Ptyp_var a
        core_type (stdlib/list.mli[60,2669+17]..[60,2669+35])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[60,2669+17]..[60,2669+24])
            Ptyp_constr "list" (stdlib/list.mli[60,2669+20]..[60,2669+24])
            [
              core_type (stdlib/list.mli[60,2669+17]..[60,2669+19])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[60,2669+28]..[60,2669+35])
            Ptyp_constr "list" (stdlib/list.mli[60,2669+31]..[60,2669+35])
            [
              core_type (stdlib/list.mli[60,2669+28]..[60,2669+30])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[65,2780+0]..[65,2780+22])
    Psig_value
    value_description "hd" (stdlib/list.mli[65,2780+4]..[65,2780+6]) (stdlib/list.mli[65,2780+0]..[65,2780+22])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[66,2803+0]..[68,2891+3])
            Pstr_eval
            expression (stdlib/list.mli[66,2803+0]..[68,2891+3])
              Pexp_constant PConst_string(" Return the first element of the given list.\n   @raise Failure if the list is empty.\n ",(stdlib/list.mli[66,2803+0]..[68,2891+3]),None)
        ]
      core_type (stdlib/list.mli[65,2780+9]..[65,2780+22])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[65,2780+9]..[65,2780+16])
          Ptyp_constr "list" (stdlib/list.mli[65,2780+12]..[65,2780+16])
          [
            core_type (stdlib/list.mli[65,2780+9]..[65,2780+11])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[65,2780+20]..[65,2780+22])
          Ptyp_var a
      []
  signature_item (stdlib/list.mli[70,2896+0]..[70,2896+27])
    Psig_value
    value_description "tl" (stdlib/list.mli[70,2896+4]..[70,2896+6]) (stdlib/list.mli[70,2896+0]..[70,2896+27])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[71,2924+0]..[73,3017+3])
            Pstr_eval
            expression (stdlib/list.mli[71,2924+0]..[73,3017+3])
              Pexp_constant PConst_string(" Return the given list without its first element.\n   @raise Failure if the list is empty.\n ",(stdlib/list.mli[71,2924+0]..[73,3017+3]),None)
        ]
      core_type (stdlib/list.mli[70,2896+9]..[70,2896+27])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[70,2896+9]..[70,2896+16])
          Ptyp_constr "list" (stdlib/list.mli[70,2896+12]..[70,2896+16])
          [
            core_type (stdlib/list.mli[70,2896+9]..[70,2896+11])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[70,2896+20]..[70,2896+27])
          Ptyp_constr "list" (stdlib/list.mli[70,2896+23]..[70,2896+27])
          [
            core_type (stdlib/list.mli[70,2896+20]..[70,2896+22])
              Ptyp_var a
          ]
      []
  signature_item (stdlib/list.mli[75,3022+0]..[75,3022+30])
    Psig_value
    value_description "nth" (stdlib/list.mli[75,3022+4]..[75,3022+7]) (stdlib/list.mli[75,3022+0]..[75,3022+30])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[76,3053+0]..[80,3251+3])
            Pstr_eval
            expression (stdlib/list.mli[76,3053+0]..[80,3251+3])
              Pexp_constant PConst_string(" Return the [n]-th element of the given list.\n   The first element (head of the list) is at position 0.\n   @raise Failure if the list is too short.\n   @raise Invalid_argument if [n] is negative.\n ",(stdlib/list.mli[76,3053+0]..[80,3251+3]),None)
        ]
      core_type (stdlib/list.mli[75,3022+10]..[75,3022+30])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[75,3022+10]..[75,3022+17])
          Ptyp_constr "list" (stdlib/list.mli[75,3022+13]..[75,3022+17])
          [
            core_type (stdlib/list.mli[75,3022+10]..[75,3022+12])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[75,3022+21]..[75,3022+30])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[75,3022+21]..[75,3022+24])
            Ptyp_constr "int" (stdlib/list.mli[75,3022+21]..[75,3022+24])
            []
          core_type (stdlib/list.mli[75,3022+28]..[75,3022+30])
            Ptyp_var a
      []
  signature_item (stdlib/list.mli[82,3256+0]..[82,3256+41])
    Psig_value
    value_description "nth_opt" (stdlib/list.mli[82,3256+4]..[82,3256+11]) (stdlib/list.mli[82,3256+0]..[82,3256+41])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[83,3298+0]..[88,3514+3])
            Pstr_eval
            expression (stdlib/list.mli[83,3298+0]..[88,3514+3])
              Pexp_constant PConst_string(" Return the [n]-th element of the given list.\n    The first element (head of the list) is at position 0.\n    Return [None] if the list is too short.\n    @raise Invalid_argument if [n] is negative.\n    @since 4.05\n ",(stdlib/list.mli[83,3298+0]..[88,3514+3]),None)
        ]
      core_type (stdlib/list.mli[82,3256+14]..[82,3256+41])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[82,3256+14]..[82,3256+21])
          Ptyp_constr "list" (stdlib/list.mli[82,3256+17]..[82,3256+21])
          [
            core_type (stdlib/list.mli[82,3256+14]..[82,3256+16])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[82,3256+25]..[82,3256+41])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[82,3256+25]..[82,3256+28])
            Ptyp_constr "int" (stdlib/list.mli[82,3256+25]..[82,3256+28])
            []
          core_type (stdlib/list.mli[82,3256+32]..[82,3256+41])
            Ptyp_constr "option" (stdlib/list.mli[82,3256+35]..[82,3256+41])
            [
              core_type (stdlib/list.mli[82,3256+32]..[82,3256+34])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[90,3519+0]..[90,3519+28])
    Psig_value
    value_description "rev" (stdlib/list.mli[90,3519+4]..[90,3519+7]) (stdlib/list.mli[90,3519+0]..[90,3519+28])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[91,3548+0]..[91,3548+21])
            Pstr_eval
            expression (stdlib/list.mli[91,3548+0]..[91,3548+21])
              Pexp_constant PConst_string(" List reversal. ",(stdlib/list.mli[91,3548+0]..[91,3548+21]),None)
        ]
      core_type (stdlib/list.mli[90,3519+10]..[90,3519+28])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[90,3519+10]..[90,3519+17])
          Ptyp_constr "list" (stdlib/list.mli[90,3519+13]..[90,3519+17])
          [
            core_type (stdlib/list.mli[90,3519+10]..[90,3519+12])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[90,3519+21]..[90,3519+28])
          Ptyp_constr "list" (stdlib/list.mli[90,3519+24]..[90,3519+28])
          [
            core_type (stdlib/list.mli[90,3519+21]..[90,3519+23])
              Ptyp_var a
          ]
      []
  signature_item (stdlib/list.mli[93,3571+0]..[93,3571+40])
    Psig_value
    value_description "init" (stdlib/list.mli[93,3571+4]..[93,3571+8]) (stdlib/list.mli[93,3571+0]..[93,3571+40])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[94,3612+0]..[97,3745+3])
            Pstr_eval
            expression (stdlib/list.mli[94,3612+0]..[97,3745+3])
              Pexp_constant PConst_string(" [init len f] is [f 0; f 1; ...; f (len-1)], evaluated left to right.\n    @raise Invalid_argument if [len < 0].\n    @since 4.06.0\n ",(stdlib/list.mli[94,3612+0]..[97,3745+3]),None)
        ]
      core_type (stdlib/list.mli[93,3571+11]..[93,3571+40])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[93,3571+11]..[93,3571+14])
          Ptyp_constr "int" (stdlib/list.mli[93,3571+11]..[93,3571+14])
          []
        core_type (stdlib/list.mli[93,3571+18]..[93,3571+40])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[93,3571+19]..[93,3571+28])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[93,3571+19]..[93,3571+22])
              Ptyp_constr "int" (stdlib/list.mli[93,3571+19]..[93,3571+22])
              []
            core_type (stdlib/list.mli[93,3571+26]..[93,3571+28])
              Ptyp_var a
          core_type (stdlib/list.mli[93,3571+33]..[93,3571+40])
            Ptyp_constr "list" (stdlib/list.mli[93,3571+36]..[93,3571+40])
            [
              core_type (stdlib/list.mli[93,3571+33]..[93,3571+35])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[99,3750+0]..[99,3750+42])
    Psig_value
    value_description "append" (stdlib/list.mli[99,3750+4]..[99,3750+10]) (stdlib/list.mli[99,3750+0]..[99,3750+42])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[100,3793+0]..[103,3965+3])
            Pstr_eval
            expression (stdlib/list.mli[100,3793+0]..[103,3965+3])
              Pexp_constant PConst_string(" Concatenate two lists. Same function as the infix operator [@].\n   Not tail-recursive (length of the first argument). The [@]\n   operator is not tail-recursive either.\n ",(stdlib/list.mli[100,3793+0]..[103,3965+3]),None)
        ]
      core_type (stdlib/list.mli[99,3750+13]..[99,3750+42])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[99,3750+13]..[99,3750+20])
          Ptyp_constr "list" (stdlib/list.mli[99,3750+16]..[99,3750+20])
          [
            core_type (stdlib/list.mli[99,3750+13]..[99,3750+15])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[99,3750+24]..[99,3750+42])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[99,3750+24]..[99,3750+31])
            Ptyp_constr "list" (stdlib/list.mli[99,3750+27]..[99,3750+31])
            [
              core_type (stdlib/list.mli[99,3750+24]..[99,3750+26])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[99,3750+35]..[99,3750+42])
            Ptyp_constr "list" (stdlib/list.mli[99,3750+38]..[99,3750+42])
            [
              core_type (stdlib/list.mli[99,3750+35]..[99,3750+37])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[105,3970+0]..[105,3970+46])
    Psig_value
    value_description "rev_append" (stdlib/list.mli[105,3970+4]..[105,3970+14]) (stdlib/list.mli[105,3970+0]..[105,3970+46])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[106,4017+0]..[109,4190+3])
            Pstr_eval
            expression (stdlib/list.mli[106,4017+0]..[109,4190+3])
              Pexp_constant PConst_string(" [rev_append l1 l2] reverses [l1] and concatenates it with [l2].\n   This is equivalent to [(]{!rev}[ l1) @ l2], but [rev_append] is\n   tail-recursive and more efficient.\n ",(stdlib/list.mli[106,4017+0]..[109,4190+3]),None)
        ]
      core_type (stdlib/list.mli[105,3970+17]..[105,3970+46])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[105,3970+17]..[105,3970+24])
          Ptyp_constr "list" (stdlib/list.mli[105,3970+20]..[105,3970+24])
          [
            core_type (stdlib/list.mli[105,3970+17]..[105,3970+19])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[105,3970+28]..[105,3970+46])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[105,3970+28]..[105,3970+35])
            Ptyp_constr "list" (stdlib/list.mli[105,3970+31]..[105,3970+35])
            [
              core_type (stdlib/list.mli[105,3970+28]..[105,3970+30])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[105,3970+39]..[105,3970+46])
            Ptyp_constr "list" (stdlib/list.mli[105,3970+42]..[105,3970+46])
            [
              core_type (stdlib/list.mli[105,3970+39]..[105,3970+41])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[111,4195+0]..[111,4195+36])
    Psig_value
    value_description "concat" (stdlib/list.mli[111,4195+4]..[111,4195+10]) (stdlib/list.mli[111,4195+0]..[111,4195+36])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[112,4232+0]..[116,4451+3])
            Pstr_eval
            expression (stdlib/list.mli[112,4232+0]..[116,4451+3])
              Pexp_constant PConst_string(" Concatenate a list of lists. The elements of the argument are all\n   concatenated together (in the same order) to give the result.\n   Not tail-recursive\n   (length of the argument + length of the longest sub-list).\n ",(stdlib/list.mli[112,4232+0]..[116,4451+3]),None)
        ]
      core_type (stdlib/list.mli[111,4195+13]..[111,4195+36])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[111,4195+13]..[111,4195+25])
          Ptyp_constr "list" (stdlib/list.mli[111,4195+21]..[111,4195+25])
          [
            core_type (stdlib/list.mli[111,4195+13]..[111,4195+20])
              Ptyp_constr "list" (stdlib/list.mli[111,4195+16]..[111,4195+20])
              [
                core_type (stdlib/list.mli[111,4195+13]..[111,4195+15])
                  Ptyp_var a
              ]
          ]
        core_type (stdlib/list.mli[111,4195+29]..[111,4195+36])
          Ptyp_constr "list" (stdlib/list.mli[111,4195+32]..[111,4195+36])
          [
            core_type (stdlib/list.mli[111,4195+29]..[111,4195+31])
              Ptyp_var a
          ]
      []
  signature_item (stdlib/list.mli[118,4456+0]..[118,4456+37])
    Psig_value
    value_description "flatten" (stdlib/list.mli[118,4456+4]..[118,4456+11]) (stdlib/list.mli[118,4456+0]..[118,4456+37])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[119,4494+0]..[121,4598+3])
            Pstr_eval
            expression (stdlib/list.mli[119,4494+0]..[121,4598+3])
              Pexp_constant PConst_string(" Same as {!concat}. Not tail-recursive\n   (length of the argument + length of the longest sub-list).\n ",(stdlib/list.mli[119,4494+0]..[121,4598+3]),None)
        ]
      core_type (stdlib/list.mli[118,4456+14]..[118,4456+37])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[118,4456+14]..[118,4456+26])
          Ptyp_constr "list" (stdlib/list.mli[118,4456+22]..[118,4456+26])
          [
            core_type (stdlib/list.mli[118,4456+14]..[118,4456+21])
              Ptyp_constr "list" (stdlib/list.mli[118,4456+17]..[118,4456+21])
              [
                core_type (stdlib/list.mli[118,4456+14]..[118,4456+16])
                  Ptyp_var a
              ]
          ]
        core_type (stdlib/list.mli[118,4456+30]..[118,4456+37])
          Ptyp_constr "list" (stdlib/list.mli[118,4456+33]..[118,4456+37])
          [
            core_type (stdlib/list.mli[118,4456+30]..[118,4456+32])
              Ptyp_var a
          ]
      []
  signature_item (stdlib/list.mli[124,4604+0]..[124,4604+21])
    Psig_attribute "ocaml.text"
    [
      structure_item (stdlib/list.mli[124,4604+0]..[124,4604+21])
        Pstr_eval
        expression (stdlib/list.mli[124,4604+0]..[124,4604+21])
          Pexp_constant PConst_string(" {1 Comparison} ",(stdlib/list.mli[124,4604+0]..[124,4604+21]),None)
    ]
  signature_item (stdlib/list.mli[126,4627+0]..[126,4627+60])
    Psig_value
    value_description "equal" (stdlib/list.mli[126,4627+4]..[126,4627+9]) (stdlib/list.mli[126,4627+0]..[126,4627+60])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[127,4688+0]..[138,5086+2])
            Pstr_eval
            expression (stdlib/list.mli[127,4688+0]..[138,5086+2])
              Pexp_constant PConst_string(" [equal eq [a1; ...; an] [b1; ..; bm]] holds when\n    the two input lists have the same length, and for each\n    pair of elements [ai], [bi] at the same position we have\n    [eq ai bi].\n\n    Note: the [eq] function may be called even if the\n    lists have different length. If you know your equality\n    function is costly, you may want to check {!compare_lengths}\n    first.\n\n    @since 4.12.0\n",(stdlib/list.mli[127,4688+0]..[138,5086+2]),None)
        ]
      core_type (stdlib/list.mli[126,4627+12]..[126,4627+60])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[126,4627+13]..[126,4627+29])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[126,4627+13]..[126,4627+15])
            Ptyp_var a
          core_type (stdlib/list.mli[126,4627+19]..[126,4627+29])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[126,4627+19]..[126,4627+21])
              Ptyp_var a
            core_type (stdlib/list.mli[126,4627+25]..[126,4627+29])
              Ptyp_constr "bool" (stdlib/list.mli[126,4627+25]..[126,4627+29])
              []
        core_type (stdlib/list.mli[126,4627+34]..[126,4627+60])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[126,4627+34]..[126,4627+41])
            Ptyp_constr "list" (stdlib/list.mli[126,4627+37]..[126,4627+41])
            [
              core_type (stdlib/list.mli[126,4627+34]..[126,4627+36])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[126,4627+45]..[126,4627+60])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[126,4627+45]..[126,4627+52])
              Ptyp_constr "list" (stdlib/list.mli[126,4627+48]..[126,4627+52])
              [
                core_type (stdlib/list.mli[126,4627+45]..[126,4627+47])
                  Ptyp_var a
              ]
            core_type (stdlib/list.mli[126,4627+56]..[126,4627+60])
              Ptyp_constr "bool" (stdlib/list.mli[126,4627+56]..[126,4627+60])
              []
      []
  signature_item (stdlib/list.mli[140,5090+0]..[140,5090+60])
    Psig_value
    value_description "compare" (stdlib/list.mli[140,5090+4]..[140,5090+11]) (stdlib/list.mli[140,5090+0]..[140,5090+60])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[141,5151+0]..[154,5674+2])
            Pstr_eval
            expression (stdlib/list.mli[141,5151+0]..[154,5674+2])
              Pexp_constant PConst_string(" [compare cmp [a1; ...; an] [b1; ...; bm]] performs\n    a lexicographic comparison of the two input lists,\n    using the same ['a -> 'a -> int] interface as {!Stdlib.compare}:\n\n    - [a1 :: l1] is smaller than [a2 :: l2] (negative result)\n      if [a1] is smaller than [a2], or if they are equal (0 result)\n      and [l1] is smaller than [l2]\n    - the empty list [[]] is strictly smaller than non-empty lists\n\n    Note: the [cmp] function will be called even if the lists have\n    different lengths.\n\n    @since 4.12.0\n",(stdlib/list.mli[141,5151+0]..[154,5674+2]),None)
        ]
      core_type (stdlib/list.mli[140,5090+14]..[140,5090+60])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[140,5090+15]..[140,5090+30])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[140,5090+15]..[140,5090+17])
            Ptyp_var a
          core_type (stdlib/list.mli[140,5090+21]..[140,5090+30])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[140,5090+21]..[140,5090+23])
              Ptyp_var a
            core_type (stdlib/list.mli[140,5090+27]..[140,5090+30])
              Ptyp_constr "int" (stdlib/list.mli[140,5090+27]..[140,5090+30])
              []
        core_type (stdlib/list.mli[140,5090+35]..[140,5090+60])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[140,5090+35]..[140,5090+42])
            Ptyp_constr "list" (stdlib/list.mli[140,5090+38]..[140,5090+42])
            [
              core_type (stdlib/list.mli[140,5090+35]..[140,5090+37])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[140,5090+46]..[140,5090+60])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[140,5090+46]..[140,5090+53])
              Ptyp_constr "list" (stdlib/list.mli[140,5090+49]..[140,5090+53])
              [
                core_type (stdlib/list.mli[140,5090+46]..[140,5090+48])
                  Ptyp_var a
              ]
            core_type (stdlib/list.mli[140,5090+57]..[140,5090+60])
              Ptyp_constr "int" (stdlib/list.mli[140,5090+57]..[140,5090+60])
              []
      []
  signature_item (stdlib/list.mli[156,5678+0]..[156,5678+20])
    Psig_attribute "ocaml.text"
    [
      structure_item (stdlib/list.mli[156,5678+0]..[156,5678+20])
        Pstr_eval
        expression (stdlib/list.mli[156,5678+0]..[156,5678+20])
          Pexp_constant PConst_string(" {1 Iterators} ",(stdlib/list.mli[156,5678+0]..[156,5678+20]),None)
    ]
  signature_item (stdlib/list.mli[159,5701+0]..[159,5701+42])
    Psig_value
    value_description "iter" (stdlib/list.mli[159,5701+4]..[159,5701+8]) (stdlib/list.mli[159,5701+0]..[159,5701+42])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[160,5744+0]..[163,5883+3])
            Pstr_eval
            expression (stdlib/list.mli[160,5744+0]..[163,5883+3])
              Pexp_constant PConst_string(" [iter f [a1; ...; an]] applies function [f] in turn to\n   [a1; ...; an]. It is equivalent to\n   [begin f a1; f a2; ...; f an; () end].\n ",(stdlib/list.mli[160,5744+0]..[163,5883+3]),None)
        ]
      core_type (stdlib/list.mli[159,5701+11]..[159,5701+42])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[159,5701+12]..[159,5701+22])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[159,5701+12]..[159,5701+14])
            Ptyp_var a
          core_type (stdlib/list.mli[159,5701+18]..[159,5701+22])
            Ptyp_constr "unit" (stdlib/list.mli[159,5701+18]..[159,5701+22])
            []
        core_type (stdlib/list.mli[159,5701+27]..[159,5701+42])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[159,5701+27]..[159,5701+34])
            Ptyp_constr "list" (stdlib/list.mli[159,5701+30]..[159,5701+34])
            [
              core_type (stdlib/list.mli[159,5701+27]..[159,5701+29])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[159,5701+38]..[159,5701+42])
            Ptyp_constr "unit" (stdlib/list.mli[159,5701+38]..[159,5701+42])
            []
      []
  signature_item (stdlib/list.mli[165,5888+0]..[165,5888+50])
    Psig_value
    value_description "iteri" (stdlib/list.mli[165,5888+4]..[165,5888+9]) (stdlib/list.mli[165,5888+0]..[165,5888+50])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[166,5939+0]..[170,6119+3])
            Pstr_eval
            expression (stdlib/list.mli[166,5939+0]..[170,6119+3])
              Pexp_constant PConst_string(" Same as {!iter}, but the function is applied to the index of\n   the element as first argument (counting from 0), and the element\n   itself as second argument.\n   @since 4.00.0\n ",(stdlib/list.mli[166,5939+0]..[170,6119+3]),None)
        ]
      core_type (stdlib/list.mli[165,5888+12]..[165,5888+50])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[165,5888+13]..[165,5888+30])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[165,5888+13]..[165,5888+16])
            Ptyp_constr "int" (stdlib/list.mli[165,5888+13]..[165,5888+16])
            []
          core_type (stdlib/list.mli[165,5888+20]..[165,5888+30])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[165,5888+20]..[165,5888+22])
              Ptyp_var a
            core_type (stdlib/list.mli[165,5888+26]..[165,5888+30])
              Ptyp_constr "unit" (stdlib/list.mli[165,5888+26]..[165,5888+30])
              []
        core_type (stdlib/list.mli[165,5888+35]..[165,5888+50])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[165,5888+35]..[165,5888+42])
            Ptyp_constr "list" (stdlib/list.mli[165,5888+38]..[165,5888+42])
            [
              core_type (stdlib/list.mli[165,5888+35]..[165,5888+37])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[165,5888+46]..[165,5888+50])
            Ptyp_constr "unit" (stdlib/list.mli[165,5888+46]..[165,5888+50])
            []
      []
  signature_item (stdlib/list.mli[172,6124+0]..[172,6124+42])
    Psig_value
    value_description "map" (stdlib/list.mli[172,6124+4]..[172,6124+7]) (stdlib/list.mli[172,6124+0]..[172,6124+42])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[173,6167+0]..[176,6332+3])
            Pstr_eval
            expression (stdlib/list.mli[173,6167+0]..[176,6332+3])
              Pexp_constant PConst_string(" [map f [a1; ...; an]] applies function [f] to [a1, ..., an],\n   and builds the list [[f a1; ...; f an]]\n   with the results returned by [f]. Not tail-recursive.\n ",(stdlib/list.mli[173,6167+0]..[176,6332+3]),None)
        ]
      core_type (stdlib/list.mli[172,6124+10]..[172,6124+42])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[172,6124+11]..[172,6124+19])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[172,6124+11]..[172,6124+13])
            Ptyp_var a
          core_type (stdlib/list.mli[172,6124+17]..[172,6124+19])
            Ptyp_var b
        core_type (stdlib/list.mli[172,6124+24]..[172,6124+42])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[172,6124+24]..[172,6124+31])
            Ptyp_constr "list" (stdlib/list.mli[172,6124+27]..[172,6124+31])
            [
              core_type (stdlib/list.mli[172,6124+24]..[172,6124+26])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[172,6124+35]..[172,6124+42])
            Ptyp_constr "list" (stdlib/list.mli[172,6124+38]..[172,6124+42])
            [
              core_type (stdlib/list.mli[172,6124+35]..[172,6124+37])
                Ptyp_var b
            ]
      []
  signature_item (stdlib/list.mli[178,6337+0]..[178,6337+50])
    Psig_value
    value_description "mapi" (stdlib/list.mli[178,6337+4]..[178,6337+8]) (stdlib/list.mli[178,6337+0]..[178,6337+50])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[179,6388+0]..[183,6587+3])
            Pstr_eval
            expression (stdlib/list.mli[179,6388+0]..[183,6587+3])
              Pexp_constant PConst_string(" Same as {!map}, but the function is applied to the index of\n   the element as first argument (counting from 0), and the element\n   itself as second argument. Not tail-recursive.\n   @since 4.00.0\n ",(stdlib/list.mli[179,6388+0]..[183,6587+3]),None)
        ]
      core_type (stdlib/list.mli[178,6337+11]..[178,6337+50])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[178,6337+12]..[178,6337+27])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[178,6337+12]..[178,6337+15])
            Ptyp_constr "int" (stdlib/list.mli[178,6337+12]..[178,6337+15])
            []
          core_type (stdlib/list.mli[178,6337+19]..[178,6337+27])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[178,6337+19]..[178,6337+21])
              Ptyp_var a
            core_type (stdlib/list.mli[178,6337+25]..[178,6337+27])
              Ptyp_var b
        core_type (stdlib/list.mli[178,6337+32]..[178,6337+50])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[178,6337+32]..[178,6337+39])
            Ptyp_constr "list" (stdlib/list.mli[178,6337+35]..[178,6337+39])
            [
              core_type (stdlib/list.mli[178,6337+32]..[178,6337+34])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[178,6337+43]..[178,6337+50])
            Ptyp_constr "list" (stdlib/list.mli[178,6337+46]..[178,6337+50])
            [
              core_type (stdlib/list.mli[178,6337+43]..[178,6337+45])
                Ptyp_var b
            ]
      []
  signature_item (stdlib/list.mli[185,6592+0]..[185,6592+46])
    Psig_value
    value_description "rev_map" (stdlib/list.mli[185,6592+4]..[185,6592+11]) (stdlib/list.mli[185,6592+0]..[185,6592+46])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[186,6639+0]..[189,6755+3])
            Pstr_eval
            expression (stdlib/list.mli[186,6639+0]..[189,6755+3])
              Pexp_constant PConst_string(" [rev_map f l] gives the same result as\n   {!rev}[ (]{!map}[ f l)], but is tail-recursive and\n   more efficient.\n ",(stdlib/list.mli[186,6639+0]..[189,6755+3]),None)
        ]
      core_type (stdlib/list.mli[185,6592+14]..[185,6592+46])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[185,6592+15]..[185,6592+23])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[185,6592+15]..[185,6592+17])
            Ptyp_var a
          core_type (stdlib/list.mli[185,6592+21]..[185,6592+23])
            Ptyp_var b
        core_type (stdlib/list.mli[185,6592+28]..[185,6592+46])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[185,6592+28]..[185,6592+35])
            Ptyp_constr "list" (stdlib/list.mli[185,6592+31]..[185,6592+35])
            [
              core_type (stdlib/list.mli[185,6592+28]..[185,6592+30])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[185,6592+39]..[185,6592+46])
            Ptyp_constr "list" (stdlib/list.mli[185,6592+42]..[185,6592+46])
            [
              core_type (stdlib/list.mli[185,6592+39]..[185,6592+41])
                Ptyp_var b
            ]
      []
  signature_item (stdlib/list.mli[191,6760+0]..[191,6760+56])
    Psig_value
    value_description "filter_map" (stdlib/list.mli[191,6760+4]..[191,6760+14]) (stdlib/list.mli[191,6760+0]..[191,6760+56])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[192,6817+0]..[196,6995+3])
            Pstr_eval
            expression (stdlib/list.mli[192,6817+0]..[196,6995+3])
              Pexp_constant PConst_string(" [filter_map f l] applies [f] to every element of [l], filters\n    out the [None] elements and returns the list of the arguments of\n    the [Some] elements.\n    @since 4.08.0\n ",(stdlib/list.mli[192,6817+0]..[196,6995+3]),None)
        ]
      core_type (stdlib/list.mli[191,6760+17]..[191,6760+56])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[191,6760+18]..[191,6760+33])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[191,6760+18]..[191,6760+20])
            Ptyp_var a
          core_type (stdlib/list.mli[191,6760+24]..[191,6760+33])
            Ptyp_constr "option" (stdlib/list.mli[191,6760+27]..[191,6760+33])
            [
              core_type (stdlib/list.mli[191,6760+24]..[191,6760+26])
                Ptyp_var b
            ]
        core_type (stdlib/list.mli[191,6760+38]..[191,6760+56])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[191,6760+38]..[191,6760+45])
            Ptyp_constr "list" (stdlib/list.mli[191,6760+41]..[191,6760+45])
            [
              core_type (stdlib/list.mli[191,6760+38]..[191,6760+40])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[191,6760+49]..[191,6760+56])
            Ptyp_constr "list" (stdlib/list.mli[191,6760+52]..[191,6760+56])
            [
              core_type (stdlib/list.mli[191,6760+49]..[191,6760+51])
                Ptyp_var b
            ]
      []
  signature_item (stdlib/list.mli[198,7000+0]..[198,7000+54])
    Psig_value
    value_description "concat_map" (stdlib/list.mli[198,7000+4]..[198,7000+14]) (stdlib/list.mli[198,7000+0]..[198,7000+54])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[199,7055+0]..[202,7167+2])
            Pstr_eval
            expression (stdlib/list.mli[199,7055+0]..[202,7167+2])
              Pexp_constant PConst_string(" [concat_map f l] gives the same result as\n    {!concat}[ (]{!map}[ f l)]. Tail-recursive.\n    @since 4.10.0\n",(stdlib/list.mli[199,7055+0]..[202,7167+2]),None)
        ]
      core_type (stdlib/list.mli[198,7000+17]..[198,7000+54])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[198,7000+18]..[198,7000+31])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[198,7000+18]..[198,7000+20])
            Ptyp_var a
          core_type (stdlib/list.mli[198,7000+24]..[198,7000+31])
            Ptyp_constr "list" (stdlib/list.mli[198,7000+27]..[198,7000+31])
            [
              core_type (stdlib/list.mli[198,7000+24]..[198,7000+26])
                Ptyp_var b
            ]
        core_type (stdlib/list.mli[198,7000+36]..[198,7000+54])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[198,7000+36]..[198,7000+43])
            Ptyp_constr "list" (stdlib/list.mli[198,7000+39]..[198,7000+43])
            [
              core_type (stdlib/list.mli[198,7000+36]..[198,7000+38])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[198,7000+47]..[198,7000+54])
            Ptyp_constr "list" (stdlib/list.mli[198,7000+50]..[198,7000+54])
            [
              core_type (stdlib/list.mli[198,7000+47]..[198,7000+49])
                Ptyp_var b
            ]
      []
  signature_item (stdlib/list.mli[204,7171+0]..[205,7191+56])
    Psig_value
    value_description "fold_left_map" (stdlib/list.mli[204,7171+4]..[204,7171+17]) (stdlib/list.mli[204,7171+0]..[205,7191+56])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[206,7248+0]..[209,7383+2])
            Pstr_eval
            expression (stdlib/list.mli[206,7248+0]..[209,7383+2])
              Pexp_constant PConst_string(" [fold_left_map] is  a combination of [fold_left] and [map] that threads an\n    accumulator through calls to [f].\n    @since 4.11.0\n",(stdlib/list.mli[206,7248+0]..[209,7383+2]),None)
        ]
      core_type (stdlib/list.mli[205,7191+2]..[205,7191+56])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[205,7191+3]..[205,7191+22])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[205,7191+3]..[205,7191+5])
            Ptyp_var a
          core_type (stdlib/list.mli[205,7191+9]..[205,7191+22])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[205,7191+9]..[205,7191+11])
              Ptyp_var b
            core_type (stdlib/list.mli[205,7191+15]..[205,7191+22])
              Ptyp_tuple
              [
                core_type (stdlib/list.mli[205,7191+15]..[205,7191+17])
                  Ptyp_var a
                core_type (stdlib/list.mli[205,7191+20]..[205,7191+22])
                  Ptyp_var c
              ]
        core_type (stdlib/list.mli[205,7191+27]..[205,7191+56])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[205,7191+27]..[205,7191+29])
            Ptyp_var a
          core_type (stdlib/list.mli[205,7191+33]..[205,7191+56])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[205,7191+33]..[205,7191+40])
              Ptyp_constr "list" (stdlib/list.mli[205,7191+36]..[205,7191+40])
              [
                core_type (stdlib/list.mli[205,7191+33]..[205,7191+35])
                  Ptyp_var b
              ]
            core_type (stdlib/list.mli[205,7191+44]..[205,7191+56])
              Ptyp_tuple
              [
                core_type (stdlib/list.mli[205,7191+44]..[205,7191+46])
                  Ptyp_var a
                core_type (stdlib/list.mli[205,7191+49]..[205,7191+56])
                  Ptyp_constr "list" (stdlib/list.mli[205,7191+52]..[205,7191+56])
                  [
                    core_type (stdlib/list.mli[205,7191+49]..[205,7191+51])
                      Ptyp_var c
                  ]
              ]
      []
  signature_item (stdlib/list.mli[211,7387+0]..[211,7387+55])
    Psig_value
    value_description "fold_left" (stdlib/list.mli[211,7387+4]..[211,7387+13]) (stdlib/list.mli[211,7387+0]..[211,7387+55])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[212,7443+0]..[214,7523+3])
            Pstr_eval
            expression (stdlib/list.mli[212,7443+0]..[214,7523+3])
              Pexp_constant PConst_string(" [fold_left f init [b1; ...; bn]] is\n   [f (... (f (f init b1) b2) ...) bn].\n ",(stdlib/list.mli[212,7443+0]..[214,7523+3]),None)
        ]
      core_type (stdlib/list.mli[211,7387+16]..[211,7387+55])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[211,7387+17]..[211,7387+31])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[211,7387+17]..[211,7387+19])
            Ptyp_var a
          core_type (stdlib/list.mli[211,7387+23]..[211,7387+31])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[211,7387+23]..[211,7387+25])
              Ptyp_var b
            core_type (stdlib/list.mli[211,7387+29]..[211,7387+31])
              Ptyp_var a
        core_type (stdlib/list.mli[211,7387+36]..[211,7387+55])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[211,7387+36]..[211,7387+38])
            Ptyp_var a
          core_type (stdlib/list.mli[211,7387+42]..[211,7387+55])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[211,7387+42]..[211,7387+49])
              Ptyp_constr "list" (stdlib/list.mli[211,7387+45]..[211,7387+49])
              [
                core_type (stdlib/list.mli[211,7387+42]..[211,7387+44])
                  Ptyp_var b
              ]
            core_type (stdlib/list.mli[211,7387+53]..[211,7387+55])
              Ptyp_var a
      []
  signature_item (stdlib/list.mli[216,7528+0]..[216,7528+56])
    Psig_value
    value_description "fold_right" (stdlib/list.mli[216,7528+4]..[216,7528+14]) (stdlib/list.mli[216,7528+0]..[216,7528+56])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[217,7585+0]..[219,7686+3])
            Pstr_eval
            expression (stdlib/list.mli[217,7585+0]..[219,7686+3])
              Pexp_constant PConst_string(" [fold_right f [a1; ...; an] init] is\n   [f a1 (f a2 (... (f an init) ...))]. Not tail-recursive.\n ",(stdlib/list.mli[217,7585+0]..[219,7686+3]),None)
        ]
      core_type (stdlib/list.mli[216,7528+17]..[216,7528+56])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[216,7528+18]..[216,7528+32])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[216,7528+18]..[216,7528+20])
            Ptyp_var a
          core_type (stdlib/list.mli[216,7528+24]..[216,7528+32])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[216,7528+24]..[216,7528+26])
              Ptyp_var b
            core_type (stdlib/list.mli[216,7528+30]..[216,7528+32])
              Ptyp_var b
        core_type (stdlib/list.mli[216,7528+37]..[216,7528+56])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[216,7528+37]..[216,7528+44])
            Ptyp_constr "list" (stdlib/list.mli[216,7528+40]..[216,7528+44])
            [
              core_type (stdlib/list.mli[216,7528+37]..[216,7528+39])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[216,7528+48]..[216,7528+56])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[216,7528+48]..[216,7528+50])
              Ptyp_var b
            core_type (stdlib/list.mli[216,7528+54]..[216,7528+56])
              Ptyp_var b
      []
  signature_item (stdlib/list.mli[222,7692+0]..[222,7692+33])
    Psig_attribute "ocaml.text"
    [
      structure_item (stdlib/list.mli[222,7692+0]..[222,7692+33])
        Pstr_eval
        expression (stdlib/list.mli[222,7692+0]..[222,7692+33])
          Pexp_constant PConst_string(" {1 Iterators on two lists} ",(stdlib/list.mli[222,7692+0]..[222,7692+33]),None)
    ]
  signature_item (stdlib/list.mli[225,7728+0]..[225,7728+60])
    Psig_value
    value_description "iter2" (stdlib/list.mli[225,7728+4]..[225,7728+9]) (stdlib/list.mli[225,7728+0]..[225,7728+60])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[226,7789+0]..[230,7962+3])
            Pstr_eval
            expression (stdlib/list.mli[226,7789+0]..[230,7962+3])
              Pexp_constant PConst_string(" [iter2 f [a1; ...; an] [b1; ...; bn]] calls in turn\n   [f a1 b1; ...; f an bn].\n   @raise Invalid_argument if the two lists are determined\n   to have different lengths.\n ",(stdlib/list.mli[226,7789+0]..[230,7962+3]),None)
        ]
      core_type (stdlib/list.mli[225,7728+12]..[225,7728+60])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[225,7728+13]..[225,7728+29])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[225,7728+13]..[225,7728+15])
            Ptyp_var a
          core_type (stdlib/list.mli[225,7728+19]..[225,7728+29])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[225,7728+19]..[225,7728+21])
              Ptyp_var b
            core_type (stdlib/list.mli[225,7728+25]..[225,7728+29])
              Ptyp_constr "unit" (stdlib/list.mli[225,7728+25]..[225,7728+29])
              []
        core_type (stdlib/list.mli[225,7728+34]..[225,7728+60])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[225,7728+34]..[225,7728+41])
            Ptyp_constr "list" (stdlib/list.mli[225,7728+37]..[225,7728+41])
            [
              core_type (stdlib/list.mli[225,7728+34]..[225,7728+36])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[225,7728+45]..[225,7728+60])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[225,7728+45]..[225,7728+52])
              Ptyp_constr "list" (stdlib/list.mli[225,7728+48]..[225,7728+52])
              [
                core_type (stdlib/list.mli[225,7728+45]..[225,7728+47])
                  Ptyp_var b
              ]
            core_type (stdlib/list.mli[225,7728+56]..[225,7728+60])
              Ptyp_constr "unit" (stdlib/list.mli[225,7728+56]..[225,7728+60])
              []
      []
  signature_item (stdlib/list.mli[232,7967+0]..[232,7967+60])
    Psig_value
    value_description "map2" (stdlib/list.mli[232,7967+4]..[232,7967+8]) (stdlib/list.mli[232,7967+0]..[232,7967+60])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[233,8028+0]..[237,8211+3])
            Pstr_eval
            expression (stdlib/list.mli[233,8028+0]..[237,8211+3])
              Pexp_constant PConst_string(" [map2 f [a1; ...; an] [b1; ...; bn]] is\n   [[f a1 b1; ...; f an bn]].\n   @raise Invalid_argument if the two lists are determined\n   to have different lengths. Not tail-recursive.\n ",(stdlib/list.mli[233,8028+0]..[237,8211+3]),None)
        ]
      core_type (stdlib/list.mli[232,7967+11]..[232,7967+60])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[232,7967+12]..[232,7967+26])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[232,7967+12]..[232,7967+14])
            Ptyp_var a
          core_type (stdlib/list.mli[232,7967+18]..[232,7967+26])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[232,7967+18]..[232,7967+20])
              Ptyp_var b
            core_type (stdlib/list.mli[232,7967+24]..[232,7967+26])
              Ptyp_var c
        core_type (stdlib/list.mli[232,7967+31]..[232,7967+60])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[232,7967+31]..[232,7967+38])
            Ptyp_constr "list" (stdlib/list.mli[232,7967+34]..[232,7967+38])
            [
              core_type (stdlib/list.mli[232,7967+31]..[232,7967+33])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[232,7967+42]..[232,7967+60])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[232,7967+42]..[232,7967+49])
              Ptyp_constr "list" (stdlib/list.mli[232,7967+45]..[232,7967+49])
              [
                core_type (stdlib/list.mli[232,7967+42]..[232,7967+44])
                  Ptyp_var b
              ]
            core_type (stdlib/list.mli[232,7967+53]..[232,7967+60])
              Ptyp_constr "list" (stdlib/list.mli[232,7967+56]..[232,7967+60])
              [
                core_type (stdlib/list.mli[232,7967+53]..[232,7967+55])
                  Ptyp_var c
              ]
      []
  signature_item (stdlib/list.mli[239,8216+0]..[239,8216+64])
    Psig_value
    value_description "rev_map2" (stdlib/list.mli[239,8216+4]..[239,8216+12]) (stdlib/list.mli[239,8216+0]..[239,8216+64])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[240,8281+0]..[243,8407+3])
            Pstr_eval
            expression (stdlib/list.mli[240,8281+0]..[243,8407+3])
              Pexp_constant PConst_string(" [rev_map2 f l1 l2] gives the same result as\n   {!rev}[ (]{!map2}[ f l1 l2)], but is tail-recursive and\n   more efficient.\n ",(stdlib/list.mli[240,8281+0]..[243,8407+3]),None)
        ]
      core_type (stdlib/list.mli[239,8216+15]..[239,8216+64])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[239,8216+16]..[239,8216+30])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[239,8216+16]..[239,8216+18])
            Ptyp_var a
          core_type (stdlib/list.mli[239,8216+22]..[239,8216+30])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[239,8216+22]..[239,8216+24])
              Ptyp_var b
            core_type (stdlib/list.mli[239,8216+28]..[239,8216+30])
              Ptyp_var c
        core_type (stdlib/list.mli[239,8216+35]..[239,8216+64])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[239,8216+35]..[239,8216+42])
            Ptyp_constr "list" (stdlib/list.mli[239,8216+38]..[239,8216+42])
            [
              core_type (stdlib/list.mli[239,8216+35]..[239,8216+37])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[239,8216+46]..[239,8216+64])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[239,8216+46]..[239,8216+53])
              Ptyp_constr "list" (stdlib/list.mli[239,8216+49]..[239,8216+53])
              [
                core_type (stdlib/list.mli[239,8216+46]..[239,8216+48])
                  Ptyp_var b
              ]
            core_type (stdlib/list.mli[239,8216+57]..[239,8216+64])
              Ptyp_constr "list" (stdlib/list.mli[239,8216+60]..[239,8216+64])
              [
                core_type (stdlib/list.mli[239,8216+57]..[239,8216+59])
                  Ptyp_var c
              ]
      []
  signature_item (stdlib/list.mli[245,8412+0]..[246,8429+58])
    Psig_value
    value_description "fold_left2" (stdlib/list.mli[245,8412+4]..[245,8412+14]) (stdlib/list.mli[245,8412+0]..[246,8429+58])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[247,8488+0]..[251,8681+3])
            Pstr_eval
            expression (stdlib/list.mli[247,8488+0]..[251,8681+3])
              Pexp_constant PConst_string(" [fold_left2 f init [a1; ...; an] [b1; ...; bn]] is\n   [f (... (f (f init a1 b1) a2 b2) ...) an bn].\n   @raise Invalid_argument if the two lists are determined\n   to have different lengths.\n ",(stdlib/list.mli[247,8488+0]..[251,8681+3]),None)
        ]
      core_type (stdlib/list.mli[246,8429+2]..[246,8429+58])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[246,8429+3]..[246,8429+23])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[246,8429+3]..[246,8429+5])
            Ptyp_var a
          core_type (stdlib/list.mli[246,8429+9]..[246,8429+23])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[246,8429+9]..[246,8429+11])
              Ptyp_var b
            core_type (stdlib/list.mli[246,8429+15]..[246,8429+23])
              Ptyp_arrow
              Nolabel
              core_type (stdlib/list.mli[246,8429+15]..[246,8429+17])
                Ptyp_var c
              core_type (stdlib/list.mli[246,8429+21]..[246,8429+23])
                Ptyp_var a
        core_type (stdlib/list.mli[246,8429+28]..[246,8429+58])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[246,8429+28]..[246,8429+30])
            Ptyp_var a
          core_type (stdlib/list.mli[246,8429+34]..[246,8429+58])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[246,8429+34]..[246,8429+41])
              Ptyp_constr "list" (stdlib/list.mli[246,8429+37]..[246,8429+41])
              [
                core_type (stdlib/list.mli[246,8429+34]..[246,8429+36])
                  Ptyp_var b
              ]
            core_type (stdlib/list.mli[246,8429+45]..[246,8429+58])
              Ptyp_arrow
              Nolabel
              core_type (stdlib/list.mli[246,8429+45]..[246,8429+52])
                Ptyp_constr "list" (stdlib/list.mli[246,8429+48]..[246,8429+52])
                [
                  core_type (stdlib/list.mli[246,8429+45]..[246,8429+47])
                    Ptyp_var c
                ]
              core_type (stdlib/list.mli[246,8429+56]..[246,8429+58])
                Ptyp_var a
      []
  signature_item (stdlib/list.mli[253,8686+0]..[254,8704+58])
    Psig_value
    value_description "fold_right2" (stdlib/list.mli[253,8686+4]..[253,8686+15]) (stdlib/list.mli[253,8686+0]..[254,8704+58])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[255,8763+0]..[259,8977+3])
            Pstr_eval
            expression (stdlib/list.mli[255,8763+0]..[259,8977+3])
              Pexp_constant PConst_string(" [fold_right2 f [a1; ...; an] [b1; ...; bn] init] is\n   [f a1 b1 (f a2 b2 (... (f an bn init) ...))].\n   @raise Invalid_argument if the two lists are determined\n   to have different lengths. Not tail-recursive.\n ",(stdlib/list.mli[255,8763+0]..[259,8977+3]),None)
        ]
      core_type (stdlib/list.mli[254,8704+2]..[254,8704+58])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[254,8704+3]..[254,8704+23])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[254,8704+3]..[254,8704+5])
            Ptyp_var a
          core_type (stdlib/list.mli[254,8704+9]..[254,8704+23])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[254,8704+9]..[254,8704+11])
              Ptyp_var b
            core_type (stdlib/list.mli[254,8704+15]..[254,8704+23])
              Ptyp_arrow
              Nolabel
              core_type (stdlib/list.mli[254,8704+15]..[254,8704+17])
                Ptyp_var c
              core_type (stdlib/list.mli[254,8704+21]..[254,8704+23])
                Ptyp_var c
        core_type (stdlib/list.mli[254,8704+28]..[254,8704+58])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[254,8704+28]..[254,8704+35])
            Ptyp_constr "list" (stdlib/list.mli[254,8704+31]..[254,8704+35])
            [
              core_type (stdlib/list.mli[254,8704+28]..[254,8704+30])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[254,8704+39]..[254,8704+58])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[254,8704+39]..[254,8704+46])
              Ptyp_constr "list" (stdlib/list.mli[254,8704+42]..[254,8704+46])
              [
                core_type (stdlib/list.mli[254,8704+39]..[254,8704+41])
                  Ptyp_var b
              ]
            core_type (stdlib/list.mli[254,8704+50]..[254,8704+58])
              Ptyp_arrow
              Nolabel
              core_type (stdlib/list.mli[254,8704+50]..[254,8704+52])
                Ptyp_var c
              core_type (stdlib/list.mli[254,8704+56]..[254,8704+58])
                Ptyp_var c
      []
  signature_item (stdlib/list.mli[262,8983+0]..[262,8983+24])
    Psig_attribute "ocaml.text"
    [
      structure_item (stdlib/list.mli[262,8983+0]..[262,8983+24])
        Pstr_eval
        expression (stdlib/list.mli[262,8983+0]..[262,8983+24])
          Pexp_constant PConst_string(" {1 List scanning} ",(stdlib/list.mli[262,8983+0]..[262,8983+24]),None)
    ]
  signature_item (stdlib/list.mli[265,9010+0]..[265,9010+45])
    Psig_value
    value_description "for_all" (stdlib/list.mli[265,9010+4]..[265,9010+11]) (stdlib/list.mli[265,9010+0]..[265,9010+45])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[266,9056+0]..[270,9267+3])
            Pstr_eval
            expression (stdlib/list.mli[266,9056+0]..[270,9267+3])
              Pexp_constant PConst_string(" [for_all f [a1; ...; an]] checks if all elements of the list\n   satisfy the predicate [f]. That is, it returns\n   [(f a1) && (f a2) && ... && (f an)] for a non-empty list and\n   [true] if the list is empty.\n ",(stdlib/list.mli[266,9056+0]..[270,9267+3]),None)
        ]
      core_type (stdlib/list.mli[265,9010+14]..[265,9010+45])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[265,9010+15]..[265,9010+25])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[265,9010+15]..[265,9010+17])
            Ptyp_var a
          core_type (stdlib/list.mli[265,9010+21]..[265,9010+25])
            Ptyp_constr "bool" (stdlib/list.mli[265,9010+21]..[265,9010+25])
            []
        core_type (stdlib/list.mli[265,9010+30]..[265,9010+45])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[265,9010+30]..[265,9010+37])
            Ptyp_constr "list" (stdlib/list.mli[265,9010+33]..[265,9010+37])
            [
              core_type (stdlib/list.mli[265,9010+30]..[265,9010+32])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[265,9010+41]..[265,9010+45])
            Ptyp_constr "bool" (stdlib/list.mli[265,9010+41]..[265,9010+45])
            []
      []
  signature_item (stdlib/list.mli[272,9272+0]..[272,9272+44])
    Psig_value
    value_description "exists" (stdlib/list.mli[272,9272+4]..[272,9272+10]) (stdlib/list.mli[272,9272+0]..[272,9272+44])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[273,9317+0]..[277,9538+3])
            Pstr_eval
            expression (stdlib/list.mli[273,9317+0]..[277,9538+3])
              Pexp_constant PConst_string(" [exists f [a1; ...; an]] checks if at least one element of\n   the list satisfies the predicate [f]. That is, it returns\n   [(f a1) || (f a2) || ... || (f an)] for a non-empty list and\n   [false] if the list is empty.\n ",(stdlib/list.mli[273,9317+0]..[277,9538+3]),None)
        ]
      core_type (stdlib/list.mli[272,9272+13]..[272,9272+44])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[272,9272+14]..[272,9272+24])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[272,9272+14]..[272,9272+16])
            Ptyp_var a
          core_type (stdlib/list.mli[272,9272+20]..[272,9272+24])
            Ptyp_constr "bool" (stdlib/list.mli[272,9272+20]..[272,9272+24])
            []
        core_type (stdlib/list.mli[272,9272+29]..[272,9272+44])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[272,9272+29]..[272,9272+36])
            Ptyp_constr "list" (stdlib/list.mli[272,9272+32]..[272,9272+36])
            [
              core_type (stdlib/list.mli[272,9272+29]..[272,9272+31])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[272,9272+40]..[272,9272+44])
            Ptyp_constr "bool" (stdlib/list.mli[272,9272+40]..[272,9272+44])
            []
      []
  signature_item (stdlib/list.mli[279,9543+0]..[279,9543+63])
    Psig_value
    value_description "for_all2" (stdlib/list.mli[279,9543+4]..[279,9543+12]) (stdlib/list.mli[279,9543+0]..[279,9543+63])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[280,9607+0]..[283,9754+3])
            Pstr_eval
            expression (stdlib/list.mli[280,9607+0]..[283,9754+3])
              Pexp_constant PConst_string(" Same as {!for_all}, but for a two-argument predicate.\n   @raise Invalid_argument if the two lists are determined\n   to have different lengths.\n ",(stdlib/list.mli[280,9607+0]..[283,9754+3]),None)
        ]
      core_type (stdlib/list.mli[279,9543+15]..[279,9543+63])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[279,9543+16]..[279,9543+32])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[279,9543+16]..[279,9543+18])
            Ptyp_var a
          core_type (stdlib/list.mli[279,9543+22]..[279,9543+32])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[279,9543+22]..[279,9543+24])
              Ptyp_var b
            core_type (stdlib/list.mli[279,9543+28]..[279,9543+32])
              Ptyp_constr "bool" (stdlib/list.mli[279,9543+28]..[279,9543+32])
              []
        core_type (stdlib/list.mli[279,9543+37]..[279,9543+63])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[279,9543+37]..[279,9543+44])
            Ptyp_constr "list" (stdlib/list.mli[279,9543+40]..[279,9543+44])
            [
              core_type (stdlib/list.mli[279,9543+37]..[279,9543+39])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[279,9543+48]..[279,9543+63])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[279,9543+48]..[279,9543+55])
              Ptyp_constr "list" (stdlib/list.mli[279,9543+51]..[279,9543+55])
              [
                core_type (stdlib/list.mli[279,9543+48]..[279,9543+50])
                  Ptyp_var b
              ]
            core_type (stdlib/list.mli[279,9543+59]..[279,9543+63])
              Ptyp_constr "bool" (stdlib/list.mli[279,9543+59]..[279,9543+63])
              []
      []
  signature_item (stdlib/list.mli[285,9759+0]..[285,9759+62])
    Psig_value
    value_description "exists2" (stdlib/list.mli[285,9759+4]..[285,9759+11]) (stdlib/list.mli[285,9759+0]..[285,9759+62])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[286,9822+0]..[289,9968+3])
            Pstr_eval
            expression (stdlib/list.mli[286,9822+0]..[289,9968+3])
              Pexp_constant PConst_string(" Same as {!exists}, but for a two-argument predicate.\n   @raise Invalid_argument if the two lists are determined\n   to have different lengths.\n ",(stdlib/list.mli[286,9822+0]..[289,9968+3]),None)
        ]
      core_type (stdlib/list.mli[285,9759+14]..[285,9759+62])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[285,9759+15]..[285,9759+31])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[285,9759+15]..[285,9759+17])
            Ptyp_var a
          core_type (stdlib/list.mli[285,9759+21]..[285,9759+31])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[285,9759+21]..[285,9759+23])
              Ptyp_var b
            core_type (stdlib/list.mli[285,9759+27]..[285,9759+31])
              Ptyp_constr "bool" (stdlib/list.mli[285,9759+27]..[285,9759+31])
              []
        core_type (stdlib/list.mli[285,9759+36]..[285,9759+62])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[285,9759+36]..[285,9759+43])
            Ptyp_constr "list" (stdlib/list.mli[285,9759+39]..[285,9759+43])
            [
              core_type (stdlib/list.mli[285,9759+36]..[285,9759+38])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[285,9759+47]..[285,9759+62])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[285,9759+47]..[285,9759+54])
              Ptyp_constr "list" (stdlib/list.mli[285,9759+50]..[285,9759+54])
              [
                core_type (stdlib/list.mli[285,9759+47]..[285,9759+49])
                  Ptyp_var b
              ]
            core_type (stdlib/list.mli[285,9759+58]..[285,9759+62])
              Ptyp_constr "bool" (stdlib/list.mli[285,9759+58]..[285,9759+62])
              []
      []
  signature_item (stdlib/list.mli[291,9973+0]..[291,9973+31])
    Psig_value
    value_description "mem" (stdlib/list.mli[291,9973+4]..[291,9973+7]) (stdlib/list.mli[291,9973+0]..[291,9973+31])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[292,10005+0]..[294,10084+3])
            Pstr_eval
            expression (stdlib/list.mli[292,10005+0]..[294,10084+3])
              Pexp_constant PConst_string(" [mem a set] is true if and only if [a] is equal\n   to an element of [set].\n ",(stdlib/list.mli[292,10005+0]..[294,10084+3]),None)
        ]
      core_type (stdlib/list.mli[291,9973+10]..[291,9973+31])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[291,9973+10]..[291,9973+12])
          Ptyp_var a
        core_type (stdlib/list.mli[291,9973+16]..[291,9973+31])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[291,9973+16]..[291,9973+23])
            Ptyp_constr "list" (stdlib/list.mli[291,9973+19]..[291,9973+23])
            [
              core_type (stdlib/list.mli[291,9973+16]..[291,9973+18])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[291,9973+27]..[291,9973+31])
            Ptyp_constr "bool" (stdlib/list.mli[291,9973+27]..[291,9973+31])
            []
      []
  signature_item (stdlib/list.mli[296,10089+0]..[296,10089+32])
    Psig_value
    value_description "memq" (stdlib/list.mli[296,10089+4]..[296,10089+8]) (stdlib/list.mli[296,10089+0]..[296,10089+32])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[297,10122+0]..[299,10229+3])
            Pstr_eval
            expression (stdlib/list.mli[297,10122+0]..[299,10229+3])
              Pexp_constant PConst_string(" Same as {!mem}, but uses physical equality instead of structural\n   equality to compare list elements.\n ",(stdlib/list.mli[297,10122+0]..[299,10229+3]),None)
        ]
      core_type (stdlib/list.mli[296,10089+11]..[296,10089+32])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[296,10089+11]..[296,10089+13])
          Ptyp_var a
        core_type (stdlib/list.mli[296,10089+17]..[296,10089+32])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[296,10089+17]..[296,10089+24])
            Ptyp_constr "list" (stdlib/list.mli[296,10089+20]..[296,10089+24])
            [
              core_type (stdlib/list.mli[296,10089+17]..[296,10089+19])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[296,10089+28]..[296,10089+32])
            Ptyp_constr "bool" (stdlib/list.mli[296,10089+28]..[296,10089+32])
            []
      []
  signature_item (stdlib/list.mli[302,10235+0]..[302,10235+25])
    Psig_attribute "ocaml.text"
    [
      structure_item (stdlib/list.mli[302,10235+0]..[302,10235+25])
        Pstr_eval
        expression (stdlib/list.mli[302,10235+0]..[302,10235+25])
          Pexp_constant PConst_string(" {1 List searching} ",(stdlib/list.mli[302,10235+0]..[302,10235+25]),None)
    ]
  signature_item (stdlib/list.mli[305,10263+0]..[305,10263+40])
    Psig_value
    value_description "find" (stdlib/list.mli[305,10263+4]..[305,10263+8]) (stdlib/list.mli[305,10263+0]..[305,10263+40])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[306,10304+0]..[310,10478+3])
            Pstr_eval
            expression (stdlib/list.mli[306,10304+0]..[310,10478+3])
              Pexp_constant PConst_string(" [find f l] returns the first element of the list [l]\n   that satisfies the predicate [f].\n   @raise Not_found if there is no value that satisfies [f] in the\n   list [l].\n ",(stdlib/list.mli[306,10304+0]..[310,10478+3]),None)
        ]
      core_type (stdlib/list.mli[305,10263+11]..[305,10263+40])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[305,10263+12]..[305,10263+22])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[305,10263+12]..[305,10263+14])
            Ptyp_var a
          core_type (stdlib/list.mli[305,10263+18]..[305,10263+22])
            Ptyp_constr "bool" (stdlib/list.mli[305,10263+18]..[305,10263+22])
            []
        core_type (stdlib/list.mli[305,10263+27]..[305,10263+40])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[305,10263+27]..[305,10263+34])
            Ptyp_constr "list" (stdlib/list.mli[305,10263+30]..[305,10263+34])
            [
              core_type (stdlib/list.mli[305,10263+27]..[305,10263+29])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[305,10263+38]..[305,10263+40])
            Ptyp_var a
      []
  signature_item (stdlib/list.mli[312,10483+0]..[312,10483+51])
    Psig_value
    value_description "find_opt" (stdlib/list.mli[312,10483+4]..[312,10483+12]) (stdlib/list.mli[312,10483+0]..[312,10483+51])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[313,10535+0]..[318,10722+3])
            Pstr_eval
            expression (stdlib/list.mli[313,10535+0]..[318,10722+3])
              Pexp_constant PConst_string(" [find f l] returns the first element of the list [l]\n   that satisfies the predicate [f].\n   Returns [None] if there is no value that satisfies [f] in the\n   list [l].\n   @since 4.05\n ",(stdlib/list.mli[313,10535+0]..[318,10722+3]),None)
        ]
      core_type (stdlib/list.mli[312,10483+15]..[312,10483+51])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[312,10483+16]..[312,10483+26])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[312,10483+16]..[312,10483+18])
            Ptyp_var a
          core_type (stdlib/list.mli[312,10483+22]..[312,10483+26])
            Ptyp_constr "bool" (stdlib/list.mli[312,10483+22]..[312,10483+26])
            []
        core_type (stdlib/list.mli[312,10483+31]..[312,10483+51])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[312,10483+31]..[312,10483+38])
            Ptyp_constr "list" (stdlib/list.mli[312,10483+34]..[312,10483+38])
            [
              core_type (stdlib/list.mli[312,10483+31]..[312,10483+33])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[312,10483+42]..[312,10483+51])
            Ptyp_constr "option" (stdlib/list.mli[312,10483+45]..[312,10483+51])
            [
              core_type (stdlib/list.mli[312,10483+42]..[312,10483+44])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[320,10727+0]..[320,10727+56])
    Psig_value
    value_description "find_map" (stdlib/list.mli[320,10727+4]..[320,10727+12]) (stdlib/list.mli[320,10727+0]..[320,10727+56])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[321,10784+0]..[325,10950+2])
            Pstr_eval
            expression (stdlib/list.mli[321,10784+0]..[325,10950+2])
              Pexp_constant PConst_string(" [find_map f l] applies [f] to the elements of [l] in order,\n    and returns the first result of the form [Some v], or [None]\n    if none exist.\n    @since 4.10.0\n",(stdlib/list.mli[321,10784+0]..[325,10950+2]),None)
        ]
      core_type (stdlib/list.mli[320,10727+15]..[320,10727+56])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[320,10727+16]..[320,10727+31])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[320,10727+16]..[320,10727+18])
            Ptyp_var a
          core_type (stdlib/list.mli[320,10727+22]..[320,10727+31])
            Ptyp_constr "option" (stdlib/list.mli[320,10727+25]..[320,10727+31])
            [
              core_type (stdlib/list.mli[320,10727+22]..[320,10727+24])
                Ptyp_var b
            ]
        core_type (stdlib/list.mli[320,10727+36]..[320,10727+56])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[320,10727+36]..[320,10727+43])
            Ptyp_constr "list" (stdlib/list.mli[320,10727+39]..[320,10727+43])
            [
              core_type (stdlib/list.mli[320,10727+36]..[320,10727+38])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[320,10727+47]..[320,10727+56])
            Ptyp_constr "option" (stdlib/list.mli[320,10727+50]..[320,10727+56])
            [
              core_type (stdlib/list.mli[320,10727+47]..[320,10727+49])
                Ptyp_var b
            ]
      []
  signature_item (stdlib/list.mli[327,10954+0]..[327,10954+47])
    Psig_value
    value_description "filter" (stdlib/list.mli[327,10954+4]..[327,10954+10]) (stdlib/list.mli[327,10954+0]..[327,10954+47])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[328,11002+0]..[331,11156+3])
            Pstr_eval
            expression (stdlib/list.mli[328,11002+0]..[331,11156+3])
              Pexp_constant PConst_string(" [filter f l] returns all the elements of the list [l]\n   that satisfy the predicate [f]. The order of the elements\n   in the input list is preserved.\n ",(stdlib/list.mli[328,11002+0]..[331,11156+3]),None)
        ]
      core_type (stdlib/list.mli[327,10954+13]..[327,10954+47])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[327,10954+14]..[327,10954+24])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[327,10954+14]..[327,10954+16])
            Ptyp_var a
          core_type (stdlib/list.mli[327,10954+20]..[327,10954+24])
            Ptyp_constr "bool" (stdlib/list.mli[327,10954+20]..[327,10954+24])
            []
        core_type (stdlib/list.mli[327,10954+29]..[327,10954+47])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[327,10954+29]..[327,10954+36])
            Ptyp_constr "list" (stdlib/list.mli[327,10954+32]..[327,10954+36])
            [
              core_type (stdlib/list.mli[327,10954+29]..[327,10954+31])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[327,10954+40]..[327,10954+47])
            Ptyp_constr "list" (stdlib/list.mli[327,10954+43]..[327,10954+47])
            [
              core_type (stdlib/list.mli[327,10954+40]..[327,10954+42])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[333,11161+0]..[333,11161+49])
    Psig_value
    value_description "find_all" (stdlib/list.mli[333,11161+4]..[333,11161+12]) (stdlib/list.mli[333,11161+0]..[333,11161+49])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[334,11211+0]..[335,11257+3])
            Pstr_eval
            expression (stdlib/list.mli[334,11211+0]..[335,11257+3])
              Pexp_constant PConst_string(" [find_all] is another name for {!filter}.\n ",(stdlib/list.mli[334,11211+0]..[335,11257+3]),None)
        ]
      core_type (stdlib/list.mli[333,11161+15]..[333,11161+49])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[333,11161+16]..[333,11161+26])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[333,11161+16]..[333,11161+18])
            Ptyp_var a
          core_type (stdlib/list.mli[333,11161+22]..[333,11161+26])
            Ptyp_constr "bool" (stdlib/list.mli[333,11161+22]..[333,11161+26])
            []
        core_type (stdlib/list.mli[333,11161+31]..[333,11161+49])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[333,11161+31]..[333,11161+38])
            Ptyp_constr "list" (stdlib/list.mli[333,11161+34]..[333,11161+38])
            [
              core_type (stdlib/list.mli[333,11161+31]..[333,11161+33])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[333,11161+42]..[333,11161+49])
            Ptyp_constr "list" (stdlib/list.mli[333,11161+45]..[333,11161+49])
            [
              core_type (stdlib/list.mli[333,11161+42]..[333,11161+44])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[337,11262+0]..[337,11262+55])
    Psig_value
    value_description "filteri" (stdlib/list.mli[337,11262+4]..[337,11262+11]) (stdlib/list.mli[337,11262+0]..[337,11262+55])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[338,11318+0]..[342,11501+2])
            Pstr_eval
            expression (stdlib/list.mli[338,11318+0]..[342,11501+2])
              Pexp_constant PConst_string(" Same as {!filter}, but the predicate is applied to the index of\n   the element as first argument (counting from 0), and the element\n   itself as second argument.\n   @since 4.11.0\n",(stdlib/list.mli[338,11318+0]..[342,11501+2]),None)
        ]
      core_type (stdlib/list.mli[337,11262+14]..[337,11262+55])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[337,11262+15]..[337,11262+32])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[337,11262+15]..[337,11262+18])
            Ptyp_constr "int" (stdlib/list.mli[337,11262+15]..[337,11262+18])
            []
          core_type (stdlib/list.mli[337,11262+22]..[337,11262+32])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[337,11262+22]..[337,11262+24])
              Ptyp_var a
            core_type (stdlib/list.mli[337,11262+28]..[337,11262+32])
              Ptyp_constr "bool" (stdlib/list.mli[337,11262+28]..[337,11262+32])
              []
        core_type (stdlib/list.mli[337,11262+37]..[337,11262+55])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[337,11262+37]..[337,11262+44])
            Ptyp_constr "list" (stdlib/list.mli[337,11262+40]..[337,11262+44])
            [
              core_type (stdlib/list.mli[337,11262+37]..[337,11262+39])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[337,11262+48]..[337,11262+55])
            Ptyp_constr "list" (stdlib/list.mli[337,11262+51]..[337,11262+55])
            [
              core_type (stdlib/list.mli[337,11262+48]..[337,11262+50])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[344,11505+0]..[344,11505+60])
    Psig_value
    value_description "partition" (stdlib/list.mli[344,11505+4]..[344,11505+13]) (stdlib/list.mli[344,11505+0]..[344,11505+60])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[345,11566+0]..[350,11847+3])
            Pstr_eval
            expression (stdlib/list.mli[345,11566+0]..[350,11847+3])
              Pexp_constant PConst_string(" [partition f l] returns a pair of lists [(l1, l2)], where\n   [l1] is the list of all the elements of [l] that\n   satisfy the predicate [f], and [l2] is the list of all the\n   elements of [l] that do not satisfy [f].\n   The order of the elements in the input list is preserved.\n ",(stdlib/list.mli[345,11566+0]..[350,11847+3]),None)
        ]
      core_type (stdlib/list.mli[344,11505+16]..[344,11505+60])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[344,11505+17]..[344,11505+27])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[344,11505+17]..[344,11505+19])
            Ptyp_var a
          core_type (stdlib/list.mli[344,11505+23]..[344,11505+27])
            Ptyp_constr "bool" (stdlib/list.mli[344,11505+23]..[344,11505+27])
            []
        core_type (stdlib/list.mli[344,11505+32]..[344,11505+60])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[344,11505+32]..[344,11505+39])
            Ptyp_constr "list" (stdlib/list.mli[344,11505+35]..[344,11505+39])
            [
              core_type (stdlib/list.mli[344,11505+32]..[344,11505+34])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[344,11505+43]..[344,11505+60])
            Ptyp_tuple
            [
              core_type (stdlib/list.mli[344,11505+43]..[344,11505+50])
                Ptyp_constr "list" (stdlib/list.mli[344,11505+46]..[344,11505+50])
                [
                  core_type (stdlib/list.mli[344,11505+43]..[344,11505+45])
                    Ptyp_var a
                ]
              core_type (stdlib/list.mli[344,11505+53]..[344,11505+60])
                Ptyp_constr "list" (stdlib/list.mli[344,11505+56]..[344,11505+60])
                [
                  core_type (stdlib/list.mli[344,11505+53]..[344,11505+55])
                    Ptyp_var a
                ]
            ]
      []
  signature_item (stdlib/list.mli[352,11852+0]..[352,11852+77])
    Psig_value
    value_description "partition_map" (stdlib/list.mli[352,11852+4]..[352,11852+17]) (stdlib/list.mli[352,11852+0]..[352,11852+77])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[353,11930+0]..[365,12423+2])
            Pstr_eval
            expression (stdlib/list.mli[353,11930+0]..[365,12423+2])
              Pexp_constant PConst_string(" [partition_map f l] returns a pair of lists [(l1, l2)] such that,\n    for each element [x] of the input list [l]:\n    - if [f x] is [Left y1], then [y1] is in [l1], and\n    - if [f x] is [Right y2], then [y2] is in [l2].\n\n    The output elements are included in [l1] and [l2] in the same\n    relative order as the corresponding input elements in [l].\n\n    In particular, [partition_map (fun x -> if f x then Left x else Right x) l]\n    is equivalent to [partition f l].\n\n    @since 4.12.0\n",(stdlib/list.mli[353,11930+0]..[365,12423+2]),None)
        ]
      core_type (stdlib/list.mli[352,11852+20]..[352,11852+77])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[352,11852+21]..[352,11852+44])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[352,11852+21]..[352,11852+23])
            Ptyp_var a
          core_type (stdlib/list.mli[352,11852+27]..[352,11852+44])
            Ptyp_constr "Either.t" (stdlib/list.mli[352,11852+36]..[352,11852+44])
            [
              core_type (stdlib/list.mli[352,11852+28]..[352,11852+30])
                Ptyp_var b
              core_type (stdlib/list.mli[352,11852+32]..[352,11852+34])
                Ptyp_var c
            ]
        core_type (stdlib/list.mli[352,11852+49]..[352,11852+77])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[352,11852+49]..[352,11852+56])
            Ptyp_constr "list" (stdlib/list.mli[352,11852+52]..[352,11852+56])
            [
              core_type (stdlib/list.mli[352,11852+49]..[352,11852+51])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[352,11852+60]..[352,11852+77])
            Ptyp_tuple
            [
              core_type (stdlib/list.mli[352,11852+60]..[352,11852+67])
                Ptyp_constr "list" (stdlib/list.mli[352,11852+63]..[352,11852+67])
                [
                  core_type (stdlib/list.mli[352,11852+60]..[352,11852+62])
                    Ptyp_var b
                ]
              core_type (stdlib/list.mli[352,11852+70]..[352,11852+77])
                Ptyp_constr "list" (stdlib/list.mli[352,11852+73]..[352,11852+77])
                [
                  core_type (stdlib/list.mli[352,11852+70]..[352,11852+72])
                    Ptyp_var c
                ]
            ]
      []
  signature_item (stdlib/list.mli[368,12428+0]..[368,12428+28])
    Psig_attribute "ocaml.text"
    [
      structure_item (stdlib/list.mli[368,12428+0]..[368,12428+28])
        Pstr_eval
        expression (stdlib/list.mli[368,12428+0]..[368,12428+28])
          Pexp_constant PConst_string(" {1 Association lists} ",(stdlib/list.mli[368,12428+0]..[368,12428+28]),None)
    ]
  signature_item (stdlib/list.mli[371,12459+0]..[371,12459+38])
    Psig_value
    value_description "assoc" (stdlib/list.mli[371,12459+4]..[371,12459+9]) (stdlib/list.mli[371,12459+0]..[371,12459+38])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[372,12498+0]..[378,12769+3])
            Pstr_eval
            expression (stdlib/list.mli[372,12498+0]..[378,12769+3])
              Pexp_constant PConst_string(" [assoc a l] returns the value associated with key [a] in the list of\n   pairs [l]. That is,\n   [assoc a [ ...; (a,b); ...] = b]\n   if [(a,b)] is the leftmost binding of [a] in list [l].\n   @raise Not_found if there is no value associated with [a] in the\n   list [l].\n ",(stdlib/list.mli[372,12498+0]..[378,12769+3]),None)
        ]
      core_type (stdlib/list.mli[371,12459+12]..[371,12459+38])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[371,12459+12]..[371,12459+14])
          Ptyp_var a
        core_type (stdlib/list.mli[371,12459+18]..[371,12459+38])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[371,12459+18]..[371,12459+32])
            Ptyp_constr "list" (stdlib/list.mli[371,12459+28]..[371,12459+32])
            [
              core_type (stdlib/list.mli[371,12459+19]..[371,12459+26])
                Ptyp_tuple
                [
                  core_type (stdlib/list.mli[371,12459+19]..[371,12459+21])
                    Ptyp_var a
                  core_type (stdlib/list.mli[371,12459+24]..[371,12459+26])
                    Ptyp_var b
                ]
            ]
          core_type (stdlib/list.mli[371,12459+36]..[371,12459+38])
            Ptyp_var b
      []
  signature_item (stdlib/list.mli[380,12774+0]..[380,12774+49])
    Psig_value
    value_description "assoc_opt" (stdlib/list.mli[380,12774+4]..[380,12774+13]) (stdlib/list.mli[380,12774+0]..[380,12774+49])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[381,12824+0]..[388,13127+3])
            Pstr_eval
            expression (stdlib/list.mli[381,12824+0]..[388,13127+3])
              Pexp_constant PConst_string(" [assoc_opt a l] returns the value associated with key [a] in the list of\n    pairs [l]. That is,\n    [assoc_opt a [ ...; (a,b); ...] = Some b]\n    if [(a,b)] is the leftmost binding of [a] in list [l].\n    Returns [None] if there is no value associated with [a] in the\n    list [l].\n    @since 4.05\n ",(stdlib/list.mli[381,12824+0]..[388,13127+3]),None)
        ]
      core_type (stdlib/list.mli[380,12774+16]..[380,12774+49])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[380,12774+16]..[380,12774+18])
          Ptyp_var a
        core_type (stdlib/list.mli[380,12774+22]..[380,12774+49])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[380,12774+22]..[380,12774+36])
            Ptyp_constr "list" (stdlib/list.mli[380,12774+32]..[380,12774+36])
            [
              core_type (stdlib/list.mli[380,12774+23]..[380,12774+30])
                Ptyp_tuple
                [
                  core_type (stdlib/list.mli[380,12774+23]..[380,12774+25])
                    Ptyp_var a
                  core_type (stdlib/list.mli[380,12774+28]..[380,12774+30])
                    Ptyp_var b
                ]
            ]
          core_type (stdlib/list.mli[380,12774+40]..[380,12774+49])
            Ptyp_constr "option" (stdlib/list.mli[380,12774+43]..[380,12774+49])
            [
              core_type (stdlib/list.mli[380,12774+40]..[380,12774+42])
                Ptyp_var b
            ]
      []
  signature_item (stdlib/list.mli[390,13132+0]..[390,13132+37])
    Psig_value
    value_description "assq" (stdlib/list.mli[390,13132+4]..[390,13132+8]) (stdlib/list.mli[390,13132+0]..[390,13132+37])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[391,13170+0]..[393,13270+3])
            Pstr_eval
            expression (stdlib/list.mli[391,13170+0]..[393,13270+3])
              Pexp_constant PConst_string(" Same as {!assoc}, but uses physical equality instead of\n   structural equality to compare keys.\n ",(stdlib/list.mli[391,13170+0]..[393,13270+3]),None)
        ]
      core_type (stdlib/list.mli[390,13132+11]..[390,13132+37])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[390,13132+11]..[390,13132+13])
          Ptyp_var a
        core_type (stdlib/list.mli[390,13132+17]..[390,13132+37])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[390,13132+17]..[390,13132+31])
            Ptyp_constr "list" (stdlib/list.mli[390,13132+27]..[390,13132+31])
            [
              core_type (stdlib/list.mli[390,13132+18]..[390,13132+25])
                Ptyp_tuple
                [
                  core_type (stdlib/list.mli[390,13132+18]..[390,13132+20])
                    Ptyp_var a
                  core_type (stdlib/list.mli[390,13132+23]..[390,13132+25])
                    Ptyp_var b
                ]
            ]
          core_type (stdlib/list.mli[390,13132+35]..[390,13132+37])
            Ptyp_var b
      []
  signature_item (stdlib/list.mli[395,13275+0]..[395,13275+48])
    Psig_value
    value_description "assq_opt" (stdlib/list.mli[395,13275+4]..[395,13275+12]) (stdlib/list.mli[395,13275+0]..[395,13275+48])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[396,13324+0]..[399,13445+3])
            Pstr_eval
            expression (stdlib/list.mli[396,13324+0]..[399,13445+3])
              Pexp_constant PConst_string(" Same as {!assoc_opt}, but uses physical equality instead of\n   structural equality to compare keys.\n   @since 4.05.0\n ",(stdlib/list.mli[396,13324+0]..[399,13445+3]),None)
        ]
      core_type (stdlib/list.mli[395,13275+15]..[395,13275+48])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[395,13275+15]..[395,13275+17])
          Ptyp_var a
        core_type (stdlib/list.mli[395,13275+21]..[395,13275+48])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[395,13275+21]..[395,13275+35])
            Ptyp_constr "list" (stdlib/list.mli[395,13275+31]..[395,13275+35])
            [
              core_type (stdlib/list.mli[395,13275+22]..[395,13275+29])
                Ptyp_tuple
                [
                  core_type (stdlib/list.mli[395,13275+22]..[395,13275+24])
                    Ptyp_var a
                  core_type (stdlib/list.mli[395,13275+27]..[395,13275+29])
                    Ptyp_var b
                ]
            ]
          core_type (stdlib/list.mli[395,13275+39]..[395,13275+48])
            Ptyp_constr "option" (stdlib/list.mli[395,13275+42]..[395,13275+48])
            [
              core_type (stdlib/list.mli[395,13275+39]..[395,13275+41])
                Ptyp_var b
            ]
      []
  signature_item (stdlib/list.mli[401,13450+0]..[401,13450+44])
    Psig_value
    value_description "mem_assoc" (stdlib/list.mli[401,13450+4]..[401,13450+13]) (stdlib/list.mli[401,13450+0]..[401,13450+44])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[402,13495+0]..[404,13618+3])
            Pstr_eval
            expression (stdlib/list.mli[402,13495+0]..[404,13618+3])
              Pexp_constant PConst_string(" Same as {!assoc}, but simply return [true] if a binding exists,\n   and [false] if no bindings exist for the given key.\n ",(stdlib/list.mli[402,13495+0]..[404,13618+3]),None)
        ]
      core_type (stdlib/list.mli[401,13450+16]..[401,13450+44])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[401,13450+16]..[401,13450+18])
          Ptyp_var a
        core_type (stdlib/list.mli[401,13450+22]..[401,13450+44])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[401,13450+22]..[401,13450+36])
            Ptyp_constr "list" (stdlib/list.mli[401,13450+32]..[401,13450+36])
            [
              core_type (stdlib/list.mli[401,13450+23]..[401,13450+30])
                Ptyp_tuple
                [
                  core_type (stdlib/list.mli[401,13450+23]..[401,13450+25])
                    Ptyp_var a
                  core_type (stdlib/list.mli[401,13450+28]..[401,13450+30])
                    Ptyp_var b
                ]
            ]
          core_type (stdlib/list.mli[401,13450+40]..[401,13450+44])
            Ptyp_constr "bool" (stdlib/list.mli[401,13450+40]..[401,13450+44])
            []
      []
  signature_item (stdlib/list.mli[406,13623+0]..[406,13623+43])
    Psig_value
    value_description "mem_assq" (stdlib/list.mli[406,13623+4]..[406,13623+12]) (stdlib/list.mli[406,13623+0]..[406,13623+43])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[407,13667+0]..[409,13771+3])
            Pstr_eval
            expression (stdlib/list.mli[407,13667+0]..[409,13771+3])
              Pexp_constant PConst_string(" Same as {!mem_assoc}, but uses physical equality instead of\n   structural equality to compare keys.\n ",(stdlib/list.mli[407,13667+0]..[409,13771+3]),None)
        ]
      core_type (stdlib/list.mli[406,13623+15]..[406,13623+43])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[406,13623+15]..[406,13623+17])
          Ptyp_var a
        core_type (stdlib/list.mli[406,13623+21]..[406,13623+43])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[406,13623+21]..[406,13623+35])
            Ptyp_constr "list" (stdlib/list.mli[406,13623+31]..[406,13623+35])
            [
              core_type (stdlib/list.mli[406,13623+22]..[406,13623+29])
                Ptyp_tuple
                [
                  core_type (stdlib/list.mli[406,13623+22]..[406,13623+24])
                    Ptyp_var a
                  core_type (stdlib/list.mli[406,13623+27]..[406,13623+29])
                    Ptyp_var b
                ]
            ]
          core_type (stdlib/list.mli[406,13623+39]..[406,13623+43])
            Ptyp_constr "bool" (stdlib/list.mli[406,13623+39]..[406,13623+43])
            []
      []
  signature_item (stdlib/list.mli[411,13776+0]..[411,13776+57])
    Psig_value
    value_description "remove_assoc" (stdlib/list.mli[411,13776+4]..[411,13776+16]) (stdlib/list.mli[411,13776+0]..[411,13776+57])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[412,13834+0]..[415,13958+3])
            Pstr_eval
            expression (stdlib/list.mli[412,13834+0]..[415,13958+3])
              Pexp_constant PConst_string(" [remove_assoc a l] returns the list of\n   pairs [l] without the first pair with key [a], if any.\n   Not tail-recursive.\n ",(stdlib/list.mli[412,13834+0]..[415,13958+3]),None)
        ]
      core_type (stdlib/list.mli[411,13776+19]..[411,13776+57])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[411,13776+19]..[411,13776+21])
          Ptyp_var a
        core_type (stdlib/list.mli[411,13776+25]..[411,13776+57])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[411,13776+25]..[411,13776+39])
            Ptyp_constr "list" (stdlib/list.mli[411,13776+35]..[411,13776+39])
            [
              core_type (stdlib/list.mli[411,13776+26]..[411,13776+33])
                Ptyp_tuple
                [
                  core_type (stdlib/list.mli[411,13776+26]..[411,13776+28])
                    Ptyp_var a
                  core_type (stdlib/list.mli[411,13776+31]..[411,13776+33])
                    Ptyp_var b
                ]
            ]
          core_type (stdlib/list.mli[411,13776+43]..[411,13776+57])
            Ptyp_constr "list" (stdlib/list.mli[411,13776+53]..[411,13776+57])
            [
              core_type (stdlib/list.mli[411,13776+44]..[411,13776+51])
                Ptyp_tuple
                [
                  core_type (stdlib/list.mli[411,13776+44]..[411,13776+46])
                    Ptyp_var a
                  core_type (stdlib/list.mli[411,13776+49]..[411,13776+51])
                    Ptyp_var b
                ]
            ]
      []
  signature_item (stdlib/list.mli[417,13963+0]..[417,13963+56])
    Psig_value
    value_description "remove_assq" (stdlib/list.mli[417,13963+4]..[417,13963+15]) (stdlib/list.mli[417,13963+0]..[417,13963+56])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[418,14020+0]..[420,14147+3])
            Pstr_eval
            expression (stdlib/list.mli[418,14020+0]..[420,14147+3])
              Pexp_constant PConst_string(" Same as {!remove_assoc}, but uses physical equality instead\n   of structural equality to compare keys. Not tail-recursive.\n ",(stdlib/list.mli[418,14020+0]..[420,14147+3]),None)
        ]
      core_type (stdlib/list.mli[417,13963+18]..[417,13963+56])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[417,13963+18]..[417,13963+20])
          Ptyp_var a
        core_type (stdlib/list.mli[417,13963+24]..[417,13963+56])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[417,13963+24]..[417,13963+38])
            Ptyp_constr "list" (stdlib/list.mli[417,13963+34]..[417,13963+38])
            [
              core_type (stdlib/list.mli[417,13963+25]..[417,13963+32])
                Ptyp_tuple
                [
                  core_type (stdlib/list.mli[417,13963+25]..[417,13963+27])
                    Ptyp_var a
                  core_type (stdlib/list.mli[417,13963+30]..[417,13963+32])
                    Ptyp_var b
                ]
            ]
          core_type (stdlib/list.mli[417,13963+42]..[417,13963+56])
            Ptyp_constr "list" (stdlib/list.mli[417,13963+52]..[417,13963+56])
            [
              core_type (stdlib/list.mli[417,13963+43]..[417,13963+50])
                Ptyp_tuple
                [
                  core_type (stdlib/list.mli[417,13963+43]..[417,13963+45])
                    Ptyp_var a
                  core_type (stdlib/list.mli[417,13963+48]..[417,13963+50])
                    Ptyp_var b
                ]
            ]
      []
  signature_item (stdlib/list.mli[423,14153+0]..[423,14153+25])
    Psig_attribute "ocaml.text"
    [
      structure_item (stdlib/list.mli[423,14153+0]..[423,14153+25])
        Pstr_eval
        expression (stdlib/list.mli[423,14153+0]..[423,14153+25])
          Pexp_constant PConst_string(" {1 Lists of pairs} ",(stdlib/list.mli[423,14153+0]..[423,14153+25]),None)
    ]
  signature_item (stdlib/list.mli[426,14181+0]..[426,14181+47])
    Psig_value
    value_description "split" (stdlib/list.mli[426,14181+4]..[426,14181+9]) (stdlib/list.mli[426,14181+0]..[426,14181+47])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[427,14229+0]..[430,14376+3])
            Pstr_eval
            expression (stdlib/list.mli[427,14229+0]..[430,14376+3])
              Pexp_constant PConst_string(" Transform a list of pairs into a pair of lists:\n   [split [(a1,b1); ...; (an,bn)]] is [([a1; ...; an], [b1; ...; bn])].\n   Not tail-recursive.\n ",(stdlib/list.mli[427,14229+0]..[430,14376+3]),None)
        ]
      core_type (stdlib/list.mli[426,14181+12]..[426,14181+47])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[426,14181+12]..[426,14181+26])
          Ptyp_constr "list" (stdlib/list.mli[426,14181+22]..[426,14181+26])
          [
            core_type (stdlib/list.mli[426,14181+13]..[426,14181+20])
              Ptyp_tuple
              [
                core_type (stdlib/list.mli[426,14181+13]..[426,14181+15])
                  Ptyp_var a
                core_type (stdlib/list.mli[426,14181+18]..[426,14181+20])
                  Ptyp_var b
              ]
          ]
        core_type (stdlib/list.mli[426,14181+30]..[426,14181+47])
          Ptyp_tuple
          [
            core_type (stdlib/list.mli[426,14181+30]..[426,14181+37])
              Ptyp_constr "list" (stdlib/list.mli[426,14181+33]..[426,14181+37])
              [
                core_type (stdlib/list.mli[426,14181+30]..[426,14181+32])
                  Ptyp_var a
              ]
            core_type (stdlib/list.mli[426,14181+40]..[426,14181+47])
              Ptyp_constr "list" (stdlib/list.mli[426,14181+43]..[426,14181+47])
              [
                core_type (stdlib/list.mli[426,14181+40]..[426,14181+42])
                  Ptyp_var b
              ]
          ]
      []
  signature_item (stdlib/list.mli[432,14381+0]..[432,14381+50])
    Psig_value
    value_description "combine" (stdlib/list.mli[432,14381+4]..[432,14381+11]) (stdlib/list.mli[432,14381+0]..[432,14381+50])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[433,14432+0]..[438,14649+3])
            Pstr_eval
            expression (stdlib/list.mli[433,14432+0]..[438,14649+3])
              Pexp_constant PConst_string(" Transform a pair of lists into a list of pairs:\n   [combine [a1; ...; an] [b1; ...; bn]] is\n   [[(a1,b1); ...; (an,bn)]].\n   @raise Invalid_argument if the two lists\n   have different lengths. Not tail-recursive.\n ",(stdlib/list.mli[433,14432+0]..[438,14649+3]),None)
        ]
      core_type (stdlib/list.mli[432,14381+14]..[432,14381+50])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[432,14381+14]..[432,14381+21])
          Ptyp_constr "list" (stdlib/list.mli[432,14381+17]..[432,14381+21])
          [
            core_type (stdlib/list.mli[432,14381+14]..[432,14381+16])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[432,14381+25]..[432,14381+50])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[432,14381+25]..[432,14381+32])
            Ptyp_constr "list" (stdlib/list.mli[432,14381+28]..[432,14381+32])
            [
              core_type (stdlib/list.mli[432,14381+25]..[432,14381+27])
                Ptyp_var b
            ]
          core_type (stdlib/list.mli[432,14381+36]..[432,14381+50])
            Ptyp_constr "list" (stdlib/list.mli[432,14381+46]..[432,14381+50])
            [
              core_type (stdlib/list.mli[432,14381+37]..[432,14381+44])
                Ptyp_tuple
                [
                  core_type (stdlib/list.mli[432,14381+37]..[432,14381+39])
                    Ptyp_var a
                  core_type (stdlib/list.mli[432,14381+42]..[432,14381+44])
                    Ptyp_var b
                ]
            ]
      []
  signature_item (stdlib/list.mli[441,14655+0]..[441,14655+18])
    Psig_attribute "ocaml.text"
    [
      structure_item (stdlib/list.mli[441,14655+0]..[441,14655+18])
        Pstr_eval
        expression (stdlib/list.mli[441,14655+0]..[441,14655+18])
          Pexp_constant PConst_string(" {1 Sorting} ",(stdlib/list.mli[441,14655+0]..[441,14655+18]),None)
    ]
  signature_item (stdlib/list.mli[444,14676+0]..[444,14676+50])
    Psig_value
    value_description "sort" (stdlib/list.mli[444,14676+4]..[444,14676+8]) (stdlib/list.mli[444,14676+0]..[444,14676+50])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[445,14727+0]..[458,15390+3])
            Pstr_eval
            expression (stdlib/list.mli[445,14727+0]..[458,15390+3])
              Pexp_constant PConst_string(" Sort a list in increasing order according to a comparison\n   function. The comparison function must return 0 if its arguments\n   compare as equal, a positive integer if the first is greater,\n   and a negative integer if the first is smaller (see Array.sort for\n   a complete specification). For example,\n   {!Stdlib.compare} is a suitable comparison function.\n   The resulting list is sorted in increasing order.\n   {!sort} is guaranteed to run in constant heap space\n   (in addition to the size of the result list) and logarithmic\n   stack space.\n\n   The current implementation uses Merge Sort. It runs in constant\n   heap space and logarithmic stack space.\n ",(stdlib/list.mli[445,14727+0]..[458,15390+3]),None)
        ]
      core_type (stdlib/list.mli[444,14676+11]..[444,14676+50])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[444,14676+12]..[444,14676+27])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[444,14676+12]..[444,14676+14])
            Ptyp_var a
          core_type (stdlib/list.mli[444,14676+18]..[444,14676+27])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[444,14676+18]..[444,14676+20])
              Ptyp_var a
            core_type (stdlib/list.mli[444,14676+24]..[444,14676+27])
              Ptyp_constr "int" (stdlib/list.mli[444,14676+24]..[444,14676+27])
              []
        core_type (stdlib/list.mli[444,14676+32]..[444,14676+50])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[444,14676+32]..[444,14676+39])
            Ptyp_constr "list" (stdlib/list.mli[444,14676+35]..[444,14676+39])
            [
              core_type (stdlib/list.mli[444,14676+32]..[444,14676+34])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[444,14676+43]..[444,14676+50])
            Ptyp_constr "list" (stdlib/list.mli[444,14676+46]..[444,14676+50])
            [
              core_type (stdlib/list.mli[444,14676+43]..[444,14676+45])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[460,15395+0]..[460,15395+57])
    Psig_value
    value_description "stable_sort" (stdlib/list.mli[460,15395+4]..[460,15395+15]) (stdlib/list.mli[460,15395+0]..[460,15395+57])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[461,15453+0]..[467,15713+3])
            Pstr_eval
            expression (stdlib/list.mli[461,15453+0]..[467,15713+3])
              Pexp_constant PConst_string(" Same as {!sort}, but the sorting algorithm is guaranteed to\n   be stable (i.e. elements that compare equal are kept in their\n   original order).\n\n   The current implementation uses Merge Sort. It runs in constant\n   heap space and logarithmic stack space.\n ",(stdlib/list.mli[461,15453+0]..[467,15713+3]),None)
        ]
      core_type (stdlib/list.mli[460,15395+18]..[460,15395+57])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[460,15395+19]..[460,15395+34])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[460,15395+19]..[460,15395+21])
            Ptyp_var a
          core_type (stdlib/list.mli[460,15395+25]..[460,15395+34])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[460,15395+25]..[460,15395+27])
              Ptyp_var a
            core_type (stdlib/list.mli[460,15395+31]..[460,15395+34])
              Ptyp_constr "int" (stdlib/list.mli[460,15395+31]..[460,15395+34])
              []
        core_type (stdlib/list.mli[460,15395+39]..[460,15395+57])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[460,15395+39]..[460,15395+46])
            Ptyp_constr "list" (stdlib/list.mli[460,15395+42]..[460,15395+46])
            [
              core_type (stdlib/list.mli[460,15395+39]..[460,15395+41])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[460,15395+50]..[460,15395+57])
            Ptyp_constr "list" (stdlib/list.mli[460,15395+53]..[460,15395+57])
            [
              core_type (stdlib/list.mli[460,15395+50]..[460,15395+52])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[469,15718+0]..[469,15718+55])
    Psig_value
    value_description "fast_sort" (stdlib/list.mli[469,15718+4]..[469,15718+13]) (stdlib/list.mli[469,15718+0]..[469,15718+55])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[470,15774+0]..[472,15855+3])
            Pstr_eval
            expression (stdlib/list.mli[470,15774+0]..[472,15855+3])
              Pexp_constant PConst_string(" Same as {!sort} or {!stable_sort}, whichever is\n    faster on typical input.\n ",(stdlib/list.mli[470,15774+0]..[472,15855+3]),None)
        ]
      core_type (stdlib/list.mli[469,15718+16]..[469,15718+55])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[469,15718+17]..[469,15718+32])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[469,15718+17]..[469,15718+19])
            Ptyp_var a
          core_type (stdlib/list.mli[469,15718+23]..[469,15718+32])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[469,15718+23]..[469,15718+25])
              Ptyp_var a
            core_type (stdlib/list.mli[469,15718+29]..[469,15718+32])
              Ptyp_constr "int" (stdlib/list.mli[469,15718+29]..[469,15718+32])
              []
        core_type (stdlib/list.mli[469,15718+37]..[469,15718+55])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[469,15718+37]..[469,15718+44])
            Ptyp_constr "list" (stdlib/list.mli[469,15718+40]..[469,15718+44])
            [
              core_type (stdlib/list.mli[469,15718+37]..[469,15718+39])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[469,15718+48]..[469,15718+55])
            Ptyp_constr "list" (stdlib/list.mli[469,15718+51]..[469,15718+55])
            [
              core_type (stdlib/list.mli[469,15718+48]..[469,15718+50])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[474,15860+0]..[474,15860+55])
    Psig_value
    value_description "sort_uniq" (stdlib/list.mli[474,15860+4]..[474,15860+13]) (stdlib/list.mli[474,15860+0]..[474,15860+55])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[475,15916+0]..[477,16006+3])
            Pstr_eval
            expression (stdlib/list.mli[475,15916+0]..[477,16006+3])
              Pexp_constant PConst_string(" Same as {!sort}, but also remove duplicates.\n    @since 4.02.0 (4.03.0 in ListLabels)\n ",(stdlib/list.mli[475,15916+0]..[477,16006+3]),None)
        ]
      core_type (stdlib/list.mli[474,15860+16]..[474,15860+55])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[474,15860+17]..[474,15860+32])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[474,15860+17]..[474,15860+19])
            Ptyp_var a
          core_type (stdlib/list.mli[474,15860+23]..[474,15860+32])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[474,15860+23]..[474,15860+25])
              Ptyp_var a
            core_type (stdlib/list.mli[474,15860+29]..[474,15860+32])
              Ptyp_constr "int" (stdlib/list.mli[474,15860+29]..[474,15860+32])
              []
        core_type (stdlib/list.mli[474,15860+37]..[474,15860+55])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[474,15860+37]..[474,15860+44])
            Ptyp_constr "list" (stdlib/list.mli[474,15860+40]..[474,15860+44])
            [
              core_type (stdlib/list.mli[474,15860+37]..[474,15860+39])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[474,15860+48]..[474,15860+55])
            Ptyp_constr "list" (stdlib/list.mli[474,15860+51]..[474,15860+55])
            [
              core_type (stdlib/list.mli[474,15860+48]..[474,15860+50])
                Ptyp_var a
            ]
      []
  signature_item (stdlib/list.mli[479,16011+0]..[479,16011+62])
    Psig_value
    value_description "merge" (stdlib/list.mli[479,16011+4]..[479,16011+9]) (stdlib/list.mli[479,16011+0]..[479,16011+62])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[480,16074+0]..[487,16443+3])
            Pstr_eval
            expression (stdlib/list.mli[480,16074+0]..[487,16443+3])
              Pexp_constant PConst_string(" Merge two lists:\n    Assuming that [l1] and [l2] are sorted according to the\n    comparison function [cmp], [merge cmp l1 l2] will return a\n    sorted list containing all the elements of [l1] and [l2].\n    If several elements compare equal, the elements of [l1] will be\n    before the elements of [l2].\n    Not tail-recursive (sum of the lengths of the arguments).\n ",(stdlib/list.mli[480,16074+0]..[487,16443+3]),None)
        ]
      core_type (stdlib/list.mli[479,16011+12]..[479,16011+62])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[479,16011+13]..[479,16011+28])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[479,16011+13]..[479,16011+15])
            Ptyp_var a
          core_type (stdlib/list.mli[479,16011+19]..[479,16011+28])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[479,16011+19]..[479,16011+21])
              Ptyp_var a
            core_type (stdlib/list.mli[479,16011+25]..[479,16011+28])
              Ptyp_constr "int" (stdlib/list.mli[479,16011+25]..[479,16011+28])
              []
        core_type (stdlib/list.mli[479,16011+33]..[479,16011+62])
          Ptyp_arrow
          Nolabel
          core_type (stdlib/list.mli[479,16011+33]..[479,16011+40])
            Ptyp_constr "list" (stdlib/list.mli[479,16011+36]..[479,16011+40])
            [
              core_type (stdlib/list.mli[479,16011+33]..[479,16011+35])
                Ptyp_var a
            ]
          core_type (stdlib/list.mli[479,16011+44]..[479,16011+62])
            Ptyp_arrow
            Nolabel
            core_type (stdlib/list.mli[479,16011+44]..[479,16011+51])
              Ptyp_constr "list" (stdlib/list.mli[479,16011+47]..[479,16011+51])
              [
                core_type (stdlib/list.mli[479,16011+44]..[479,16011+46])
                  Ptyp_var a
              ]
            core_type (stdlib/list.mli[479,16011+55]..[479,16011+62])
              Ptyp_constr "list" (stdlib/list.mli[479,16011+58]..[479,16011+62])
              [
                core_type (stdlib/list.mli[479,16011+55]..[479,16011+57])
                  Ptyp_var a
              ]
      []
  signature_item (stdlib/list.mli[489,16448+0]..[489,16448+30])
    Psig_attribute "ocaml.text"
    [
      structure_item (stdlib/list.mli[489,16448+0]..[489,16448+30])
        Pstr_eval
        expression (stdlib/list.mli[489,16448+0]..[489,16448+30])
          Pexp_constant PConst_string(" {1 Lists and Sequences} ",(stdlib/list.mli[489,16448+0]..[489,16448+30]),None)
    ]
  signature_item (stdlib/list.mli[491,16480+0]..[491,16480+32])
    Psig_value
    value_description "to_seq" (stdlib/list.mli[491,16480+4]..[491,16480+10]) (stdlib/list.mli[491,16480+0]..[491,16480+32])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[492,16513+0]..[494,16554+3])
            Pstr_eval
            expression (stdlib/list.mli[492,16513+0]..[494,16554+3])
              Pexp_constant PConst_string(" Iterate on the list.\n    @since 4.07\n ",(stdlib/list.mli[492,16513+0]..[494,16554+3]),None)
        ]
      core_type (stdlib/list.mli[491,16480+13]..[491,16480+32])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[491,16480+13]..[491,16480+20])
          Ptyp_constr "list" (stdlib/list.mli[491,16480+16]..[491,16480+20])
          [
            core_type (stdlib/list.mli[491,16480+13]..[491,16480+15])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[491,16480+24]..[491,16480+32])
          Ptyp_constr "Seq.t" (stdlib/list.mli[491,16480+27]..[491,16480+32])
          [
            core_type (stdlib/list.mli[491,16480+24]..[491,16480+26])
              Ptyp_var a
          ]
      []
  signature_item (stdlib/list.mli[496,16559+0]..[496,16559+32])
    Psig_value
    value_description "of_seq" (stdlib/list.mli[496,16559+4]..[496,16559+10]) (stdlib/list.mli[496,16559+0]..[496,16559+32])
      attribute "ocaml.doc"
        [
          structure_item (stdlib/list.mli[497,16592+0]..[499,16643+3])
            Pstr_eval
            expression (stdlib/list.mli[497,16592+0]..[499,16643+3])
              Pexp_constant PConst_string(" Create a list from a sequence.\n    @since 4.07\n ",(stdlib/list.mli[497,16592+0]..[499,16643+3]),None)
        ]
      core_type (stdlib/list.mli[496,16559+13]..[496,16559+32])
        Ptyp_arrow
        Nolabel
        core_type (stdlib/list.mli[496,16559+13]..[496,16559+21])
          Ptyp_constr "Seq.t" (stdlib/list.mli[496,16559+16]..[496,16559+21])
          [
            core_type (stdlib/list.mli[496,16559+13]..[496,16559+15])
              Ptyp_var a
          ]
        core_type (stdlib/list.mli[496,16559+25]..[496,16559+32])
          Ptyp_constr "list" (stdlib/list.mli[496,16559+28]..[496,16559+32])
          [
            core_type (stdlib/list.mli[496,16559+25]..[496,16559+27])
              Ptyp_var a
          ]
      []
]

